---
title:  "YouTube 클론코딩 개념 정리"
excerpt: "#3 express, #4 routers, #5 templates, #6 mongoDB and mongoose, #7 user authentication"
date:   2021-11-25 23:20:32 +0900
categories: web
tags:
  javascript
  node.js	
  mongoDB
toc: true
toc_sticky: true


---



## #2 SET UP

babel을 이용해 최신 문법코드를 쓸 수 있다 https://babeljs.io/

=> 최신문법코드를 node.js가 이해할수있게 번역

babel, config.json이란 babel이 알아서 이 파일을  찾고 내용을 들여다본다 

preset은 babel을 위한 플러그인 preset-env가 유명(최신 자바스크립트 구문을 사용할 수 있게 해줌)

"scripts":{"dev": "babel-node index.js"} : node.js가 실행되는데 babel도 적용돼서 실행



nodemon은 우리가 만든 파일이 수정되는걸 감시해주는 패키지

파일이 수정되면 nodemon이 알아서 재시작

[노드몬 설치]

 npm i nodemon --save-dev



```javascript
"scripts":{"dev": "nodemon --exec babel-node index.js"}
```

'babel-node'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
배치 파일이 아닙니다. 이란 오류가 나온다

환경변수에 babel-node가 없어 찾지못해 에러가 발생하는거라는데

```javascript
"scripts":{"dev": "nodemon --exec npx babel-node index.js"}
```

로 바꿔주면 실행된다



## #3.1~3.11 server, controlleres, middleware Recap

\# **Server**

> 서버는 인터넷에 연결되어 있으며 24시간 꺼지지 않는 컴퓨터이다.
>
> 서버는 클라이언트(여기서는 브라우저)에서 보낸 request 를 받고 response 보낸다.

\# **Request, Response**

> 클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
>
> 서버는 request 를 받으면 반드시 response 를 해주어야 한다. 브라우저 무한 로딩이 될 수 있기 때문이다.
>
> HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.

\# **Controller**

> 컨트롤러는 전달받은 request를 처리하고 response를 전달하기 위한 콜백함수이다. 컨트롤러는 request 와 response 오브젝트를 전달받는다.

\# **Middleware**

> 미들웨어는 컨트롤러가 request 처리 작업을 완료하고 response 를 전달하기 전에 request 처리를 도와주는 콜백함수이다.
>
> 미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
>
> next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있다.
>
> 1. 미들웨어는 요청과 응답 사이의 소프트웨어.
> 2. 모든 미들웨어는 핸들러, 모든 컨트롤러는 미들웨어다.
> 3. 미들웨어는 next를 포함한 세 개의 argument가 있다. (req, res, enxt)
> 4. next 존재하는 경우 다음 핸들러 함수 next()를 호출.
> 5. middleware에는 next() 가 필수 !!!!
>
> **morgan**
>
> morgan은 node.js용 request logger middleware다.
>
> npm i morgan으로 설치
>
> import morgan form "morgan";
>
> 



## #어딘지 기억안남

middleware는 작업을 다음 함수에게 넘기는 함수, 응답하는 함수 X

mixin 은 partial이긴 한데 데이터를 받을 수 있는 partial

------

href의 앞머리에 / 를 넣으면 어디있든 상관없이 root경로 + /

/를 지우면 현재경로에 / 붙혀서 감

=> 제일앞에 /가있으면 절대경로(videos router에서 실행)
a(href="/video/edit")--->localhost:4000/video/edit
a(href="video/edit")--->localhost:4000/videos/video/edit
a(href=`${video.id}/edit`)--->localhost:4000/videos/1/edit

------

**method는 form과 back end 사이의 정보 전송에 관한 방식**

**get**

> 그 form에 있는 정보가 url에 들어가 검색할 때 필요 검색페이지를 만들 때 사용 그 검색어는 url안에 들어감, 데이터를 오직 받는 목적이라면 get

**post** 

> 데이터베이스에 추가, 수정, 삭제 할 때

------

**app.use(express.urlencoded({extended: true}));**

> express application가 form의 value들을 이해할수 있도록 하고 우리가 쓸 수 있는 자바스크립트 형식으로 변형시켜 준다

> req.body: form의 value값 받기 ex) const {username, password} = req.body

> input에 name넣는걸 까먹으면 req.body에는 데이터가 없다



#4.1 ~ 5.10

코드보는게 편해서 뺌



## #6.8 Connecting to Mongo

Windows 에서 mongo 설치했는데 cmd에서 mongodb커맨드 안될때

https://dangphongvanthanh.wordpress.com/2017/06/12/add-mongos-bin-folder-to-the-path-environment-variable/





## #6.11 Our First Query

server.js

> server.js는 server의 configuration에 관련된 코드만 처리하기 위해 만들어졌으므로 database나 models같은것은 분리해줘야함



callback

> javascript 에서 기다림을 표현하는 하나의 방법이라 생각



Video.find({}) 

> {}는 serch terms,  이게 비어있으면 모든 형식을 찾는다
>
> logger은 request가 완성되면 출력이 돼야함



return의 역할

> 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.

> 이러한 경우 return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용render한 것은 다시 render할 수 없음

> redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)



## #6.22 Edit Video part Three

```javascript
export const watch = async (req, res) => {
  const { id } = req.params; 
  //const video = await Video.exists({_id:id});
  const video = await Video.findById(id);
  if(video===null){
    return res.render("404", { pageTitle: "Video not found" });
  }

  return res.render("watch", {pageTitle: video.title, video})
};
```

여기에서는 exist를 사용하면 안됨, object를 edit templete으로 보내줘야함

exist는 그냥 존재여부 확인

## #6.23 Middlewares

1. 몽고 사용하기 

> mongo

2. 내가 가진 db 보기 

> show dbs

3. 현재 사용 중인 db 확인 

> db

4. 사용할 db 선택하기 

> use dbName
> (현재 수업에서는 `use wetube`)

5. db 컬렉션 보기 

> show collections

6. db 컬렉션 안에 documents 보기

>                                db.collectionName.find()
>                              (현재 수업에서는 `db.videos.find()`)

7. db 컬렉션 안에 documents 모두 제거하기 

> db.collectionName.remove({})
> (현재 수업에서는 `db.videos.remove({})`)
>
> 

**[몽구스 가이드]** 

**https://mongoosejs.com/docs/guide.html**



**middleware**

> **model이 생성되기 전에 만들어야 함**
>
> ex)
>
> userSchema.pre("save", async function(){  //middleware
>
> this.password = await bcrypt.hash(this.password,5);
>
> })
>
> const User = mongoose.model("user", userSchema); //model

**default export는** 

> import Video, { formatHashtags } from "../models/Video"
>
> 라고 치면 Video가 defalut export고 {formatHashtags}가 export



## #6.24 Statics

1. findByIdAndUpdate()에서는 save 훅업이 발생하지 않음 => 다른 방법을 알아보자
2. Video.js에 function을 만들어서 관리하기 => 이것도 괜찮음 근데 다른것도 알아보자
3. static을 사용하면 import 없이도 Model.function()형태로 사용이 가능함 => super cool



## #6.25 Delete

Model.findOneAndDelete()
Model.findOneAndRemove()

> 이 둘은 정말 약간의 차이가 있는데 대부분의 상황에서 타당한 이유가 없는 한 delete를 사용하라고 되어 있음.

> https://www.zerocho.com/category/MongoDB/post/579ecb1fc097d015000404dd
>
> 여기 글을 읽어보니 몽고 db는 롤백이 안되서 remove를 하면 다시 되돌릴 수 없기에 remove보다 delete를 사용하라고 권장하는듯



## #6.26 Search part One

form을 보내면 그 내용은 req.body로 받을 수 있음, => post에서

search 화면에서는 req.query로 받음 => get에서 인듯??



## #6.27 Search part Two

[정규표현식]
https://www.regexpal.com

[몽고DB regex]
https://docs.mongodb.com/manual/reference/operator/query/regex

[RegExp mdn]
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp

[정규표현식 참고사이트]

https://wormwlrm.github.io/2020/07/19/Regular-Expressions-Tutorial.html



## #7.2 Creating Account part Three

[비밀번호 털렸다고? 암호화. 해시함수. 5분 설명 영상]
https://www.youtube.com/watch?v=67UwxR3ts2E

[remove() 명령어 실행이 안될 때] 																			db.users.remove()는 deprecated되었기 때문에 ?
db.users.deleteMany({})로 지우기

[해시함수 테스트]
https://emn178.github.io/online-tools/sha256.html

[패키지 설치]
npm i bcrypt



## #7.3 Form Validation

**$or operator: 조건중 하나만 참이어도 값 가져오기**

```javascript
const exists = await User.exists({$or:[{username},{email}]});
```

몽구스 예전버전은 지원 X



## #7.4 Status Codes

[상태코드]
https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

> \- 200(OK): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
> \- 400(Bad Request): 서버가 요청의 구문을 인식하지 못할 때 발생한다. 클라이언트 측에서 문제가 있을 때 주로 발생한다.
> \- 404(Not Found): 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.



## #7.6 Login part Two

bcrypt가 생성하는 것을 보면 솔트가 해시의 시작 부분에 있음을 알 수 있다

> ex)$2b$**07**$FxSgL.mY0VlBKg0i7Q/Lp.AUciZE./C2UqtFCU93n7ZC7a0e0ge22
>
> =>07, sort 7번



## #7.7 Sessions and Cookies part One

[세션, 토큰, 쿠키 개념 10분 설명 영상]

https://www.youtube.com/watch?v=tosLBcAX1vk 

쿠키 

> 그냥 옮기는 시스템. 매개체

토큰

> 서버가 기억하는 이상하게 생긴 텍스트 

JWT

> 정보를 갖고있는 토큰, DB 없이 검증가능



1. 브라우져 서버에 접근
2. 서버가 브라우져에게 Cookie 준다.
3. 브라우져가 서버에 다시 접근할 때 2.에서 받은 Cookie를 함께 건냄.
4. 서버는 Cookie를 통해 브라우져를 구분 할 수 있다.

**쿠키를 통해 세션ID 전달 O, 세션data 전달 X**



## #7.8 Sessions and Cookies part Two

**세션은 서버측에서 제공해주는 데이터, 쿠키는 클라이언트측에서 저장하고 사용하는 데이터**

req.sessiontStore() 사용했을때 한번은 undefined가 나온 이유가 세션은 서버에서 만들어줘야 하는데 클라이언트가 첫 요청때 세션을 가지고있을리 없으니 undefined이 나온거고 그 이후 요청부턴 **첫번째 요청때 세션을 만들어서 넘겨**줬으니 **클라이언트가 해당 값을 쿠키에 저장**하고 매 요청때마다 서버에게 전달
세션은 서버가 만들어서 제공해주다보니 서버가 재부팅되면 초기화 된다. (그래서 DB에 저장해서 관리를 한다는 소리. 실 운영에선 서버가 꺼지는 일은 없으니깐.)
세션의 값은 서버가 만들어주는 고유값이다보니 해당 값을 기준으로 클라이언트에서 요청한 건에 대해 유저를 특정지을 수 있다



즉, 브라우져에서 서버에 로그인 요청을 해서 로그인이 되면 서버는 세션id를 response해주고
브라우져는 쿠키스토리지에 그 세션id를 보관하고 있다가 이후 다시 서버에 방문할 시에는 그 세션
id만 보여주면 자동으로 로그인되게 해줘서 계속 로그인할 수고를 덜어준다는 것이다



## #7.10 Logged In User part Two

res.locals로 저장된 locals변수는 브라우져에 저장되는게 아니라 서버에 저장되는거



## #7.11 Login Recap

**Cookie, Session**

cookie랑 session은 별개의 개념



**cookie**

> 단지 정보를 주고받는일만 한다
>
> cookie의 장점은 자동적으로 처리되는거 사용자는 아무것도 안해도된다
>
> cookie는 sessionID를 저장하고 서버로 전송시켜 backend에도 sessionID를 저장시킨다

> 브라우저는 우리가 매번 backend localhost에 있는 URL로 request를 보낼 때 마다 cookie가 request랑 같이 전송됨 



**Session store**

> session을 저장하는곳



## #7.12 MongoStore

session id는 쿠키에 저장하지만, session데이터 자체는 서버에 저장

서버에 저장되는 default session storage는 MemoryStore이고, 실제 사용하기 위해 있는건 아님

그래서 session을 데이터베이스에 저장해야함

**[connect-mongo] (세션을 몽고디비에 저장)**

npm i connect-mongo

https://www.npmjs.com/package/connect-mongo



**이미 mongoose 가 mongodb 와 연결되어 있는데 connect-mongo 에 dbURL을 전달해 한번더 연결을 하는 이유가 있나요?**

store: MongoStore.create({ client: connection.client })

위와같이 하면 mongoose 의 client 를 사용해서 세션정보를 저장할 수 있는거같습니다

=> 안해봄



## #7.13 Uninitialized Sessions

**[resave, saveUninitialized 참고자료]**

**https://mongojs.tistory.com/26**

**resave(true,false)** 

> session이 store에서 삭제되면 다시 store에 저장될것이냐 

**saveUninitialized : true** 

>  따로 값을 설정하지 않은 전달 받은 날 것의 세션을 즉시 Store에 저장 후 세션 주인에게 쿠키를 (답장하듯) 넘겨 준다.  --> 말 그대로 값이 초기화(initialize)되지 않아도 저장

**saveUninitialized: false** 

>   req.session 속 값을 수정하는 그 순간에 세션을 Store에 저장 후 그제야 쿠키를 전달한다.(backend가 로그인 한 사용자들에게만 쿠키를 주도록 설정) --> 값이 초기화될때 저장

> =>로그인할때 { req.session.loggedIn = true, req.session.user = user} 





session authentication(인증)을 사용하면서 생길 수 있는 문제점?

## #7.14 Expiration and Secrets

쿠키의 프로퍼티에 대해(Name, Value, Domain, Path, Expires / Max-Age, Size, HttpOnly, Secure, SameSite, Priority)

**Secret**

>  쿠키에 sign 할 때 사용하는 string, 쿠키에 sign하는 이유는 backend가 쿠키를 줬다는걸 보여주기 위함, session hijack(납치, 누군가 쿠키를 훔쳐 마치 본인인거처럼 하는것)라는 공격유형을 방어하기 위함 이 string을 가지고 쿠키를 sign하고 우리가 만든것임을 증명하기위해 쓰임

**Domain**

> 이 쿠키를 만든 backend가 누구인지 알려줌

**Path**

> 그냥 url

**Expires**

> 만료날자를 정하지않으면 값이 session으로 돼있는데 사용자가 닫으면 session 쿠키는 끝나게됨, 예를들어 몇몇브라우저에서 프로그램을 닫거나 컴퓨터를 재시작 할 때 이 쿠키는 사라지는거다 (이해가 잘 안됨)

**Max-Age**

> 언제 session이 만료되는지 정하는거에 쓰인다

```javascript
app.use(session({
    secret:"Hello",
    resave:true,
    saveUninitialized: true,
    cookie: {
        maxAge: 20000, // => 20초 뒤에 만료
    },
    store: MongoStore.create({mongoUrl:"mongodb://127.0.0.1:27017/wetube"})
}))

```



## #7.15 Environment Variables

**env파일**

> 모든 AP key나 모든 비밀로 해야하는 url을 넣는곳

**evn파일에 접근하는법**

> process.env.variableName

**dotenv**

> env파일을 읽고 각각의 변수들을 process.env안에 넣어준다\



dotenv는 가장 위에 import를 해줘야함, env를 로드하기위해 

import 대신 require("dotenv").config();로 받아오려면 dotenv를 사용하려는 모든 파일의 첫번째에 해줘야한다 너무 비효율적이므로 가장 처음으로 실행되는 파일에 import하자

**npm i dotenv**

https://www.npmjs.com/package/dotenv

import dotenv from "dotenv", dotenv.config() 대신
import "dotenv/config"로 바로 dotenv config함수를 불러와서 실행 가능



## #7.16 Github Login part One

깃허브 OAuth Apps
https://github.com/settings/developers

깃허브 OAuth Apps 공식문서
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps



깃허브로그인 절차

 	1. 사용자를 깃허브로 보내기(로그인)
 	2. 우리에게 정보를 공유하는 것을 승인 
 	3. 깃헙은 사용자를 token과 함께 우리 웹사이트로 redirect 시킴
 	4. 우리는 그 token으로 사용자의 정보를 받아옴 token이 빠르게 만료



**GET https://github.com/login/oauth/authorize** 
Parmeters

> client_id: 등록할 때 github에서 받은 클라이언트 ID (필수)
>
> redirect_uri string: 승인 후 사용자가 전송될 애플리케이션의 URL
>
> scope: 사용자가 정보를 어디까지 공유해야하는지
>
> allow_signup(true, false): 인증되지 않은 사용자에게 회원가입 옵션 제공
>
> login: 로그인하고 인증하는데 사용할 특정 계정을 제안(?)
>
> state: .사이트 요청 간 공격으로부터 보호(?)

