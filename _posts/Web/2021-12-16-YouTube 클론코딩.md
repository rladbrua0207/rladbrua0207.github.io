---
title:  "YouTube 클론코딩"
excerpt: "#3 express, #4 routers, #5 templates, #6 mongoDB and mongoose, #7 user authentication, #8 user profile, #9 webpack, #10 styles"
date:   2021-12-16 23:20:32 +0900
categories: web
tags:
  web
  javascript
  node.js	
  mongoDB
toc: true
toc_sticky: true




---



## #1 INTRODUCTION

**Node.js**

- 브라우저 밖에서 돌아가는 자바스크립트
- 90년대 자바스크립트는 브라우저에서만 사용됐었는데 웹사이트와 좀 더 상호작용 할 수 있도록 만들었음. 
- Ryan Dahl은 NodeJS를 만들어서 자바스크립트를 웹 말고도 다른 곳에서도 사용하고자 하였고 구글 크롬에서 자바스크립트를 꺼내서 NodeJS를 사용할 수 있게 됌.
- 전에는 자바스크립트와 다른 것으로 김치전처럼 HTML, CSS, 브라우저와 섞여서 만들었는데 자바스크립트를 브라우저에서 분리해서 NodeJS를 만듬. NodeJS를 만들고 난 후, 브라우저에서 Python, Java, C처럼 프로그래밍 언어로 만드니깐 백엔드를 만들 수 있고, 파일 이름을 바꿔서 스크립트도 만들 수 있고, 이미지 처리 등을 할 수 있게 되었고 다른 프로그래밍 언어들처럼 쓸 수 있게 됌.
- NodeJS는 브라우저 바깥에서 쓸 수 있는 자바스크립트이다. VSCode에서 node 명령어를 치면 console.log("hi') 처럼 다양한 명령어를 구글 크롬 콘솔에서 사용하듯이 가능하다.
- NodeJS 덕분에 React Reactive도 사용하고 Electron도 사용할 수 있게 됌. -> chromium과 NodeJS 덕분이다.
- VSCode는 HTML, CSS, Javascript, Electron등으로 만들어짐. 
- React Native로는 JS와 ReactJS를 사용해서 안드로이드, iOS 앱을 만들 수 있게 되었다.
- NodeJS 덕분에 ReactJS 같은 것도 쓸 수 있게 되었다, NodeJS가 자바스크립트로 컴파일 해주기 때문이다.



**NPM**

- 자바스크립트 언어를 위한 패키지 매니저 => npm과 nodeJS를 같이 써야한다.
- npm은 NodeJS와 상호작용을 할 수 있게 해준다.
- npm은 NodeJS를 설치할때 같이 설치된다.
- npm은 여러 곳에 있는 대단한 사람들이 작은 패키지를 만들어주고 공유할 수 있고 그 패키지를 가져다 쓸 수 있다(개발을 더 편하고 쉽게해줌)

## #2 SET UP

#### #2.0 Your First Node JS Project

강의목표

- nodeJS 프로젝트 만들기
- package.json
- github repository 연결

**package.json**

- 파일명은 무조건 package.json이어야 하고 nodeJS 프로젝트를 만들 때 가장 먼저 만들어야 할 파일이다. => 이게 node.js의 장점 시작점이 작다.

**github repository 연결**

1. git init

2. git remote add origin "repository주소"

**package.json파일 만들기**

![image-20211221011436642](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211221011436642.png)

=>결과로 pack.json 파일 생성

![image-20211221011614441](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211221011614441.png)



#### #2.1 Installing Express

강의목표

- index.js의 코드를 package.json을 가지고 어떻게 실행하는지, 여기서 npm은 어떻게 쓰는지

 다른사람이 내 패키지를 설치하면 main을 사용하게되므로 다른사람한테 공유할게 아니고 main은 필수요소가 아니므로 지워도됨

```json
"scripts": {
	"win": "node index.js"
}
```

이렇게 scripts를 추가하면 터미널에 npm run win을 입력하면 node의 index.js가 실행이된다

```javascript
//index.js
console.log("Hello NodeJS");
```

![image-20211222234304647](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211222234304647.png)

나중에는 서버를 시작하는 Script, CSS 압축하는 script 웹사이트를 빌드하고 서버에 배포하는 script 등등 많은 스크립트를 만들게될거다



**express 패키지 설치**

> npm i express

처음 패키지를 설치한거라 node_module폴더와 package-lock라는 파일이 생성되었다.

**node_modules**

- npm으로 설치한 모든 패키지가 저장

패키지끼리는 서로 체인처럼 연결되어있다
express를 설치하는데 의존하고 있는 패키지가 있기때문에![image-20211222234834375](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211222234834375.png)

express 외의 패키지들도 같이 생성되었다

또 package.json 파일에

```json
  "dependencies": {
    "express": "^4.17.2"
  }
```

가 추가되었다.



#### #2.2 Understanding Dependencies

강의목표

- dependencies
- package-lock.json

**dependencies**

> npm은 npm install을 할 때 package.json파일의 dependencies를 찾아 그 안에 있는 모듈들을 알아서 설치한다. package.json은 프로젝트를 동작시킬때 필요한 모듈들이 어떤건지 정보를 dependencies에 담고있다. 그래서 node_module을 삭제했더라도 package.json만 있으면 npm install 만 해주면 알아서 설치해준다 컴퓨터를 바꿀때나 팀프로젝트를 할때 유용하다

**devDependencies**

- 개발자에게 필요한 dependencies
- ex) babel

**dependencies**

- 프로젝트에 필요한 dependencies
- ex) express

**package-lock.json**

- 패키지를 안전하게 관리해준다
  - 패키지가 수정됐는지 해시값으로 체크
- 다른사람이 package.json(npm install)으로 express를 설치하면(npm install express 말고) 
  package.json, package-lock.json, index.js를 주고 다른사람이 패키지를 똑같은 버전의 모듈을 설치하도록 해준다.
- 관리 할 필요가 없다 npm이 다 알아서 해결해줌

npm install ~ 할때는 npm이 dependencies를 수정해 버전충돌이 일어날 수 있으므로  package.json을 꼭 닫고 실행해야한다.



#### #2.3 The Tower of Babel

강의목표

- babel 패키지 설치, 설정

babel은 javascript 컴파일러

babel을 이용해 최신 문법코드를 쓸 수 있다 https://babeljs.io/

=> 최신문법코드를 node.js가 이해할수있게 번역

**babel 패키지 설치, 설정**

> npm install --save-dev @babel/core
>
> --save-dev : package.json의 devDependencies로 저장
>
> 추가적으로 필요한 패키지 설치
> npm install @babel/preset-env --save-dev
>
> babel.config.json파일 만든 후 그 파일에 presets 코드 추가
> 참고: https://babeljs.io/setup#installation
>
> ```json
> //@babel/core와 @babel/preset-env를 설치한 후 설정
> {
> "presets": ["@babel/preset-env"]
> }
> //presets은 babel을 위한 엄청 거대한 플러그인이다 그중 preset-env가 가장 유명 =>최신 자바스크립트를 쓸 수 있게 해줌
> ```
>
> babel이 babel.config.json파일을 찾아서 설정까지 한다. 하지만 아직 babel을 사용하는건 아니다
>
> 참고 사이트를 보면 babel은 
>
> ```javascript
> require("@babel/core").transform("code", {
> presets: ["@babel/preset-env"],
> });
> ```
>
> 이런식으로 실행 해 주지만 자바스크립트에서 직접 babel을 사용하지 않을거기 때문에 이방법은 사용하지않는다.
>
> 대신 package.json에 babel로 컴파일하는 scripts를 만들거다 => nodemon
>
> nodemon을 사용하기전에 설치해야 할 패키지
> npm install @babel/node --save-dev
>
> 참고: https://babeljs.io/setup#installation
>
> ```json
> "scripts": {
>  "dev": "babel-node index.js"
> },
> //이걸 실행하면 nodeJS가 실행되는데 babel도 적용돼서 실행된다 그러면 최신 문법 코드를 동작시킬 수 있다.
> ```



#### #2.4 Nodemon

강의목표

- nodemon으로 파일이 수정 될 때 마다 실행

**nodemon**

> 만든 파일이 수정되는걸 감시해주는 패키지(npm run dev를 계속 해 줄 필요가 없다)
>
> nodemon패키지설치
> npm i nodemon --save -dev
>
> 이제 package.json의 scripts를 바꿔주면 nodemon 실행가능
>
> ```json
> "scripts": {
> "dev": "nodemon --exec babel-node index.js"
> }
> ```
>
> 이렇게되면 babel-node index.js 를 실행하고도 콘솔 창이 종료되지 않는다.
>
> ![image-20211223013917267](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211223013917267.png)
>
> 근데 'babel-node'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
> 배치 파일이 아닙니다. 이란 오류가 나온다면
>
> 환경변수에 babel-node가 없어 찾지못해 에러가 발생하는거라는데
>
> ```javascript
> "scripts":{
> "dev": "nodemon --exec npx babel-node index.js"
> }
> ```
>
> 로 바꿔주면 실행된다
>
> 이게 npx 내부명령으로  babel-node를 실행하라는건데 처음에 노드버전을 최신버전으로 할때는 이 오류가 나왔다가 노드 버전을 다운그레이드 하고 하니깐 오류가 안난다



### #2.5 Recap

package.json생성

1. 정보를 담는 text
2. 몇몇 항목은 작성하면, npm을 통해 이용할 수 있는게 있다.
   - script
     - 작성하면, npm run xxx의 형식으로 실행가능.
   - dependencies
     - 프로젝트를 실행하는데 필요한 packages.
     - npm i를 입력하면, dependencies와 Devdependencies를 보고 필요한 것들을 자동으로 node_moudels에 저장해준다.
   - devDependencies
     - 개발자가 개발하는데 필요한 packages
3. babel
   - sexy한 ES6로 코드를 작성하고 싶지만, 최신 NodeJS도 인식하지 못할때가 있다.
   - 그래서 babel로 평범한 node로 변환해서 돌린다.
   - 사용하기 위해서는 bebel.config.json 파일을 만들어야 한다.





## #3 INTRODUCTION TO EXPRESS

### #3.0 Your First Server

강의목표

- 서버만들기

**Server**

- 항상 켜져있는 컴퓨터와 같은 것.
- request를 기다리고있다.

```javascript
import express from "express";
//node_modules의 express라는 패키지를 express라는 이름으로 import
//npm은 이렇게하면 node_modules에서 express를 찾고 있다는 걸 알아낸다.

const PORT = 4000; 

const app = express();
//expess application 생성

const handleListening = () => console.log(`Server listening on port http://localhost:${PORT}`)

app.listen(PORT, handleListening);
//서버가 사람들이 뭔가 요청할 때 까지 기다리는 함수 어떤포트를 리스닝할지 알려줘야함
//사용하지않는 포트면 상관 없는데 보통 높은 숫자의 포트 일수록 비어있다.

//보통 서버를 시작했다면 로컬호스트로 들어갈수있다 ex)localhost:4000
```

서버로 들어가면 ![image-20211223024001991](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211223024001991.png)이러한 응답이 나오는데 이게 서버만드는데 성공한거다.



### #3.1 ~ 3.2 GET Requests

강의목표

1. get requests
2. http
3. 서버에게, get requests에 어떻게 응답해야 할지를 알려주기

HTTP

- 우리가 서버와 소통하는 방법, 서버가 서로 소통하는 방법이다.
- 유저가 웹사이트에 들어가려고 할 때 브라우저가 http request를 만들어 보낸다.
- http request: 웹사이트에 접속하고 서버에 정보를 보내준다.

GET

- 웹사이트에 접속하려 할 때 웹사이트한테 홈페이지좀 갖다 줘 라고 요청하는것이다.
- 브라우저는 사용자를 대신해 웹사이트를 request하고, 페이지를 get 하려는것이다

```javascript
import express from "express";

const PORT = 4000;
const app = express();

const handleHome = () => console.log("somebody is trying to go home.");

app.get("/", handleHome);
//"/"root 페이지로 get 요청을 보내면 함수를 실행한다.
//handleHome 자리에는 반드시 함수를 넣어야한다.

const handleListening = () =>
  console.log(`Server listening on port http://localhost:${PORT}`);
app.listen(PORT, handleListening);
```

결과 => ![image-20211223031209137](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211223031209137.png) 무한로딩을 한다. 

handle function에 console.log만 있을뿐, 아무런 response를 해주지 않았기 때문



### #3.3 Responses

강의목표

1. request후 response하는 과정 
2. responses에는 어떠 종류가 있는지

```javascript
//server.js
const handleHome = (req, res) => {return res.send("I still love you.");}
//req, res는 express로 부터 받는거다.

app.get("/", handleHome);
//home(/)으로 get request가 오면 express는 handleHome에다가 (req, res) request와 response object를 넣어준다 request object에는 header, cookie, url, method등등이 있다
```

1. app.get("URL",GET handlerfunction")은 get 요청을한다 그렇지만 꼭 get요청에 응답하는것은 아니다.
2. 서버가 사용자의 get 요청에 응답하도록 하려면  res.end() 또는 res.send() 등등의 응답을 해줘야한다 
   ex) 
   handleHome = (req, res) => res.end() , 
   handleHome = (req, res) => {return res.send("I still love you.");};
3. GET의 첫번째 인수는 req이며 request객체를 받는다.
4. GET의 두번째 인수는 res이며 response객체를 받는다.
5. res.end()는 아무것도 반환하지 않고 응답을 종료하고 res.send()는 사용자가 입력한 문자열을 반환한다.



### #3.4 Recap

request를 받고 respond 한다.

- status code, html, end()등으로 respond



### #3.5 Middlewares part One

강의목표

1. 본격적으로 웹사이트를 만들기 전에 middleware의 개념 이해

```javascript
// middleware
const gossipMiddleware = (req, res, next) => {
  console.log(`Someone is goint to: ${req.url}`);
  next();
};
// finalware
const handleHome = (req, res) => {
  return res.send("I love middlewares");
};

app.get("/", gossipMiddleware, handleHome);
```

1. middleware
   - 요청과 응답 사이 중간에있는 소프트웨어(middle software)
   - 모든 미들웨어는 핸들러(컨트롤러) 미들웨어이다.
   - 세 개의 인수가 있다 (req, res, next)
   - next인수가 존재하는경우 next는 다음 컨트롤러를 호출한다



### #3.4 Middlewares part Two

강의목표

1. app.get()말고도 다른것도 있다는걸 배운다 => app.use

**app.use**

- gloable middleware을 만들게 해준다.
  - 어느 URL에도 작동하는 middleware

```javascript
const logger = (req, res, next) => {
  console.log(`${req.method} ${req.url}`);
  next();//next()를 호출하지 않는다면 다음 컨트롤러가 실행이 안돼 끝나버린다. middleware사용할때 next() 호출하는거 까먹지말기 !
};

const privateMiddleWare = (req, res, next) => {
  const url = req.url;
  if (url === "/protected") {
    return res.send("<h1>Not Allowed</h1>");
  }
  console.log("Allowed, you may continue.");
  next();
};

const handleHome = (req, res) => {
  return res.send("I love middlewares");
};

const handleProtected = (req, res) => {
  return res.send("Welcome to the private lounge.");
};

app.use(logger);
app.use(privateMiddleWare);
app.get("/", handleHome);
app.get("/protected", handleProtected);

const handleListening = () =>
  console.log(`Server listening on port http://localhost:${PORT}`);

app.listen(PORT, handleListening);

// 위결과로, handleprotected는 실행되지 않고, privateMiddleWare에서 끝나게 됨.
```

> 위에서 사용자가 /protected 경로로 요청을 보낸다면 req의 url이 값을 비교해 res.send("<h1>Not Allowed</h1>");를 return해준다 privatedMiddleware는 url을 감시하는 역할인거다.



### #3.7 Setup Recap

#2 내용이라 아래 주소에 포스팅
https://til-blog.tistory.com/5



### #3.8 Servers Recap

**Server**

- 서버는 인터넷에 연결되어 있으며 24시간 꺼지지 않는 컴퓨터이다.
- 클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
- 서버는 request 를 받으면 반드시 response 를 해주어야 한다. 브라우저 무한 로딩이 될 수 있기 때문이다.
- HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.
- request
  - 댓글을 쓰거나, 주소로 들어가거나 할때 브라우저가 request를 보내는 거임.
  - 브라우저를 통한 모든 상호작용.
- port
  - 컴퓨터와 소통하기 위한 창문같은 것.





### #3.9 Controller Recap

**Controller**

- 전달받은 request를 처리하고 response를 전달하기 위한 콜백함수이다
- 컨트롤러는 request 와 response 오브젝트를 전달받는다.
  - request를 받았으면, response (end(),send())를 함으로써 응답을 해야한다.
  - 아무 response가 없다면 브라우저는 무한로딩하며 우리의 대답을 기다릴 것.



### #3.10 Middleware Recap

**Middleware**

- 미들웨어는 컨트롤러가 request 처리 작업을 완료하고 response 를 전달하기 전에 request 처리를 도와주는 콜백함수이다.
- 미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
- next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있다.
  1. 미들웨어는 요청과 응답 사이의 소프트웨어.
  2. 모든 미들웨어는 핸들러, 모든 컨트롤러는 미들웨어다.
  3. 미들웨어는 next를 포함한 세 개의 argument가 있다. (req, res, enxt)
  4. next가 존재하는 경우 다음 핸들러 함수 next()를 호출.
  5. middleware에는 next() 가 필수 !!!!



### #3.11 External Midddlewares

**morgan**

- node.js용 request logger middleware.
- 패키지설치
  npm i morgan
- morgan을 통해 method, path, status code 등의 정보를 요청을 보낼 때 마다 콘솔을 통해 확인할수 있다.

```javascript
import express from "express";

import morgan from "morgan";

const PORT = 4000;

const app = express();
//dev, short, tiny, combined, common중에 출력유형선택.
const logger = morgan("dev");

const home = (req, res) => {
  console.log("I will respond.");
  return res.send("I love middlewares");
};

const login = (req, res) => {
  return res.send("login");
};

app.use(logger);
app.get("/", home);
app.get("/login", login);

const handleListening = () =>
  console.log(`Server listening on port http://localhost:${PORT}`);

app.listen(PORT, handleListening);
```

결과 => method, path, 응답시간

![image-20211223160554892](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211223160554892.png)







## #4 Routers

정리를 안해둬서 https://onlee3.github.io/clonecoding/WetubeC4/ 참고
이분 너무 정리를 잘해두셨다

### #4.0 What are Routers

```
/ -> Home
/join -> Join
/login -> Login
/search -> Search

/users/edit -> Edit Profile
/users/delete -> Delete Profile

/videos/watch -> Watch Video
/videos/edit -> Edit Video
/videos/delete -> Delete Video
/videos/comment -> Comment on a Video
/videos/comments/delete -> Delete a Comment a Video
```

1. router는 URL을 그룹화해준다

   - / :global router

   - /users : users router

   - /videos : videos router

2. 프로젝트 설계시 고려할 사항
   - 어떤 데이터를 사용할 것인가?
     - wetube의 경우
       - 동영상을 올리고 수정하고, 댓글을 작성하고 삭제하고 하는 등의 행동들이 메인
       - 즉 유저, 동영상 이 두가지가 메인 데이터



### #4.1 Making Our Routers

- 규칙에 따르지 않는 예외적인 Router를 만드는 이유
  1. /, /join, /login, /search 등
  2. URL이 직관적이고 보기에 예쁘면, 홍보하거나 소개할때 더 유용함.
  3. 기술적으로는 문제없음. 예외적으로 만들지 않고 그냥 해도됨.



### #4.2 Cleaning the Code

창작 과정 이후에는 코드 정리 과정이 필요하다. (clean code 책 참고)

1. 만들 때는 생각나는 대로, 만드는게 중요.
2. 코드를 작성한 시간 만큼 할애해서, 정리할 것.

```javascript
import express from "express";

const globalRouter = express.Router();

const handleHome = (req, res) => res.send("Home");

globalRouter.get("/", handleHome);
// 해당 js를 import하면, globalRouter 자체를 import하게 될 것이다.
export default globalRouter;
```

모든 파일은 모듈이고 거품과 같다. (NodeJS의 중요한 컨셉)

1. import하기전에 export 해야한다.
2. 모든 파일은 독립되어 있음.

```javascript
import express from "express";
import morgan from "morgan";

import globalRouter from "./routers/globalRouter";
import videoRouter from "./routers/videoRouter";
import userRouter from "./routers/userRouter";

const PORT = 4000;

const app = express();
const logger = morgan("dev");
app.use(logger);
// ""로 시작하는 URL로 들어가면 express는 해당 라우터 안으로 들어간다.
// 라우터 내부에서, express는 url의 나머지 주소를 찾는다.
app.use("/", globalRouter);
app.use("/videos", videoRouter);
app.use("/users", userRouter);

const handleListening = () =>
  console.log(`Server listening on port http://localhost:${PORT}`);

app.listen(PORT, handleListening);

// Inside of GlobalRouter.js
import express from "express";

const globalRouter = express.Router();

const handleHome = (req, res) => res.send("Home");

globalRouter.get("/", handleHome);

export default globalRouter;
```



### #4.3 Exports

```javascript
//Controller.js
/* export default로 export 하는 경우.
다른 문서에서는 import xx from "xx";로 표기하면 된다.
이 경우 xx는 이름이 같지 않아도됨.*/
const join = (req, res) => res.send("Join");

export default join;

---
/* 각 변수를 export 하는 경우.
다른 문서에서는 import { xx } from "xx"로 표기
이 경우 xx는 기존 문서에 있는 변수명과 같아야함.*/
export const trending = (req, res) => res.send("Home Page Videos");
export const watch = (req, res) => res.send("Watch");
export const edit = (req, res) => res.send("Edit");

---
// Router.js
import express from "express";
import { join } from "../controllers/userController";
import { trending } from "../controllers/videoController";

const globalRouter = express.Router();

globalRouter.get("/", trending);
globalRouter.get("/join", join);

export default globalRouter;
```

경로지정 팁

- ../ : 해당문서 바깥
- ./ : 해당문서 장소



### #4.4 Router Recap

라우터는 공통 시작부분을 기반으로 url을 정리해주는 방법



### #4.5 Architecture Recap

1. 변수를 다른 파일로부터 가져온다.
2. 무언가를 임포트하기전에는 익스포트를 먼저 해야한다.
3. 글로벌 라우터를 위해 글로벌 컨트롤러를 따로 만들지는 않음.
   - 글로벌 라우터를 만든 건 URL을 예쁘게 정리하기 위해서임.
   - 사용자, 동영상 2개의 컨트롤러 만으로도 구분해서 사용가능.



### #4.6 Planning Routes

```javascript
//# Wetube Reloaded
/ -> Home
/join -> Join
/login -> Login
/search -> Search

/users/:id -> See User
/users/logout -> Log Out
/users/edit -> Edit MY Profile
/users/delete -> Delete MY Profile

/videos/:id -> See Video
/videos/:id/edit -> Edit Video
/videos/:id/delete -> Delete Video
/videos/upload -> Upload Video

//videoRouter.js
import express from "express";
import { see, edit, upload, deleteVideo } from "../controllers/videoController";

const videoRouter = express.Router();

videoRouter.get("/:id", see);
videoRouter.get("/:id/edit", edit);
videoRouter.get("/:id/delete", deleteVideo);
videoRouter.get("/upload", upload);

export default videoRouter;

//videoController.js
export const trending = (req, res) => res.send("Home Page Videos");
export const see = (req, res) => res.send("Watch");
export const edit = (req, res) => res.send("Edit");
export const search = (req, res) => res.send("Search");
export const upload = (req, res) => res.send("Upload");
export const deleteVideo = (req, res) => res.send("Delete Video");
```

사용자 입장에서 어떻게 사용될지 생각하고, URL을 설계하고 코딩해나간다.



### #4.7 URL Parameters part One

```javascript
//videoRouter.js
import express from "express";
import { see, edit, upload, deleteVideo } from "../controllers/videoController";

const videoRouter = express.Router();

/* upload를 가장 위로 두는 이유
videoRouter.get("/:id", see); 가 위에 있으면
/upload라는 url을 id로 인식하여 upload 함수를 실행시키고 페이지를 종료시켜버린다.*/
videoRouter.get("/upload", upload);
videoRouter.get("/:id", see);
videoRouter.get("/:id/edit", edit);
videoRouter.get("/:id/delete", deleteVideo);

export default videoRouter;

//videoController.js
export const trending = (req, res) => res.send("Home Page Videos");
export const see = (req, res) => {
  // id 넘버를 확인하기 위해 console.log
  console.log(req.params);
  return res.send(`Watch Video #${req.params.id}`);
};
export const edit = (req, res) => {
  console.log(req.params);
  return res.send("Edit");
};
export const search = (req, res) => res.send("Search");
export const upload = (req, res) => {
  console.log(req.params);
  return res.send("Upload");
};
export const deleteVideo = (req, res) => {
  console.log(req.params);
  return res.send("Delete Video");
};
```

parameter

- : 기호가 들어가야함
- 사용함으로써 url안에 변수를 포함 시킬 수 있게됨.



### #4.8 URL Parameters part Two

현재 문제점

- 숫자외의 url도 id로 인식해버림.
- Regular Expression (정규식)
  - 모든 프로그래밍 언어에 존재

```javascript
videoRouter.get("/upload", upload);
videoRouter.get("/:id(\\d+)", see);
videoRouter.get("/:id(\\d+)/edit", edit);
videoRouter.get("/:id(\\d+)/delete", deleteVideo);
// (\\d+) : 숫자만 받음 (digital)
// 해당 프로젝트에서는 이렇게 안쓸예정. (데이터베이스의 형태가 다르기 때문에)
```



## #5 TEMPLATES

 https://onlee3.github.io/clonecoding/WetubeC4/ 참고

### #5.1 Configuring Pug

- pug는 tempate engine
- 패키지설치
  npm i pug

```javascript
const app = express();
app.set("view engine", "pug");
// express app의 view engine으로 pug 지정
```

기본적으로 express는 cwd (currentWorkingDirectory) + /views에서 pug 파일을 찾는다.

```javascript
//videoController.js
export const trending = (req, res) => {
  /*render로 home.pug를 렌더링함.
server.js에서 view engine으로써 pug를 지정해줬으므로, 따로 import할 필요는 없음.
미리만들어둔 views폴더 내에서 view를 찾게 됨.*/
  res.render("home");
};
```



### #5.2 Partials.

[app.set(name, value)](https://www.notion.so/210c348e862b4d48a9ab40ab5809214d)

**views default**

- express에게 views 폴더가 어디있는지 알려줘야함.
- `process.cwd() + '/views'`
- 현재 우리 폴더는, src내부에 views 폴더가 있으므로 경로 수정.

```javascript
app.set("views", process.cwd() + "/src/views");
```

pug 주의점

1. 파일명에 뛰어 쓰기 하지 말것.
2. 파일명은 전부 소문자로 할 것.

pug 장점

1. 쉽고 sexy한 html 작성
2. 내용에 자바스크립트를 포함시킬수 있음.
3. 반복하지 않고 한 파일로 모든 템플릿을 업데이트 할 수 있음.

Partials

1. footer, header 등등 같은 부분을 매 페이지마다 수정하기 번거로움.
2. include 기능을 사용해 다른페이지를 가져올 수 있음.

```javascript
//base.pug
doctype html
html(lang="ko")
    head
        title #{pageTitle} | GyeomTube
    body
        include partials/header.pug
        main
        include partials/footer.pug
```



### #5.3 Extending Templates

inheritance (상속)

- 레이아웃, html의 베이스를 만들어줌.
- pug에서는 extends를 사용함으로써 가능.

block

- pug에서, 다른 페이지에서 내용을 채워넣을 수 있도록 공간을 만들어 낼 수 있음.
- block을 채우지 않고 공란으로 냅둬도 작동함.



### #5.4 Variables to Templates

- render()는 두가지 인자를 받는다.
  1. view의 이름
  2. template에 보낼 변수

```javascript
/* 1. view인 "home"을 렌더링하고, home.pug는 base.pug
를 extends해서 복사해옴.
2. base.pug에서 받는 변수값 pageTitle을 입력해줌.*/
export const trending = (req, res) => {
  res.render("home", { pageTitle: "Home" });
};
```



### #5.6 MVP Styles

```javascript
link(rel="stylesheet" href="https://unpkg.com/mvp.css")
//style 간단하게 적용
```



### #5.8 Iteration

**Iteration**

- Elements의 list를 보여주는 것.
- 이를 위해선 template에 array인 variable이 있어야함.

```javascript
// videoController.js
export const trending = (req, res) => {
  const videos = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  return res.render("home", { pageTitle: "Home", videos });
    //home template에 pageTitle과 videos 전달
};

//home.pug
extends base.pug

block content
    h2 Welcome here you will see trending videos
    ul
        each video in videos
            li=video
		else
            li Sorry nothing found.
// video = currenvalue of loop, 즉 videos array안의 각 item. (이름은 자유롭게 지어도됨)
// videos = videoController에서 받아온 array형태의 변수. (이름이 서로 일치해야함)
```



### #5.9 Mixins

- Mixin
  1. partials(footer.pug같은 것) that we can receive data
  2. 똑똑한 partial
  3. 데이터를 받을 수 있는 일종의 미리 만들어진 HTML BLOCK



```javascript
// videoController.js
export const trending = (req, res) => {
  const videos = [
    {
      title: "First Video",
      rating: 5,
      comments: 2,
      createdAt: "2 minutes ago",
      views: 59,
      id: 1,
    },
    {
      title: "Second Video",
      rating: 5,
      comments: 2,
      createdAt: "2 minutes ago",
      views: 59,
      id: 2,
    },
    {
      title: "Third Video",
      rating: 5,
      comments: 2,
      createdAt: "2 minutes ago",
      views: 59,
      id: 3,
    },
  ];
  return res.render("home", { pageTitle: "Home", videos });
};

//video.pug (mixin)
mixin video(info)
    div
        h4=info.title
        ul
            li #{info.rating}/5.
            li #{info.comments} comments.
            li Posted #{info.createdAt}.
            li #{info.views} views.

//home.pug
extends base.pug
// include 경로지정
include mixins/video

block content
    h2 Welcome here you will see trending videos
    each potato in videos
// video.pug 안의 video function에 potato 객체를 넣음.
// potato : videos array의 한 item
        +video(potato)//+를 붙히면 mixin 호출 
    else
        li Sorry nothing found.
```







## #6 MONGODB AND MONGOOSE

### #6.0 ~ 6.1 Array Database

> Absolute URL and Relative URL

href의 앞머리에 / 를 넣으면 어디있든 상관없이 root경로 + /

/를 지우면 현재경로에 / 붙혀서 감

```javascript
//=> 제일앞에 /가있으면 절대경로(videos router에서 실행)
a(href="/video/edit")--->localhost:4000/video/edit
a(href="video/edit")--->localhost:4000/videos/video/edit
a(href=`${video.id}/edit`)--->localhost:4000/videos/1/edit
```



### #6.2 ~ 6.3 Edit Video

**method는 form과 back end 사이의 정보 전송에 관한 방식**

> get

- 그 form에 있는 정보가 url에 들어가 검색할 때 필요 검색페이지를 만들 때 사용 그 검색어는 url안에 들어감, 데이터를 오직 받는 목적이라면 get

> post

- post 방식은 파일을 보내거나, database에 있는 값을 바꾸는 뭔가를 보낼 때 사용함
- 웹사이트에 로그인 할때도 사용



> route()를 이용한 shortcut

- 하나의 URL에 get,post 방식을 쓰도록 할때 유용함.

```javascript
videoRouter.route("/:id(\\d+)/edit").get(getEdit).post(postEdit);
/*
videoRouter.get("/:id(\\d+)/edit", getEdit);
videoRouter.post("/:id(\\d+)/edit", postEdit); 와 같음
*/
```

> res.redirect()

- 브라우저가 해당 URL redirect (자동으로 이동)하도록 하는 것.

> app.use(express.urlencoded({extended: true}));

- express application가 form의 value들을 이해할수 있도록 하고 우리가 쓸 수 있는 자바스크립트 형식으로 변형시켜 준다

- req.body: form의 value값 받기 ex) const {username, password} = req.body

- input에 name넣는걸 까먹으면 req.body에는 데이터가 없다



### #6.4 Recap

> req.body

1. form 안에 있는 value의 javascript representation
2. app.use(express.urlencoded)를 이용해야만 사용가능.
   - 해당 middleware의 순서도 중요! videoRouter보다 먼저 앞에 와야만 req.body가 준비되있음.
3. input에 name을 설정해주지 않으면, req.body는 비어있음.

> mongodb and mongoose

1. mongodb
   - 초급자,상급자 모두 다루기 좋은 database.
2. mongoose
   - 이를 통해 자바스크립트에서 mongodb와 상호작용 할 것. /blue



### #6.7 Introduction to MongoDB

> MongoDB

1. general purpose
2. document-based
   - 큰 장점.
   - 보통은 sql-based (액셀처럼 행과열이있는 것)임.
3. database를 object로 생각
   - JSON-like documents.
   - document를 검색하고 만들거나 삭제할 기회를 줌.

### #6.8 Connecting to Mongo

Windows 에서 mongo 설치했는데 cmd에서 mongodb커맨드 안될 때

https://dangphongvanthanh.wordpress.com/2017/06/12/add-mongos-bin-folder-to-the-path-environment-variable/



> mongoose

1. node.js와 mongoDB를 이어주는 다리
2. validation, query building, hook 등 많은게 존재

> 터미널로 mongoDB 확인

1. mongod입력으로 설치 확인
2. mongo 입력으로 mongodb실행
   - help
     - 사용가능한 명령어 볼 수 있음
   - show dbs
     - 가지고 있는 DB 보여줌

> mongoose 패키지설치

- npm i mongoose

> mongoose 연결

```javascript
//db.js
import mongoose from "mongoose";
//terminal에서 mongo 실행뒤, 나오는 URL복사.
// 뒤에는 꼭 이름(wetube)을 추가해줘야함.
mongoose.connect("mongodb://127.0.0.1:27017/wetube");
```

```javascript
//server.js
import "./db";
// 파일 그 자체를 import함. 이 파일을 import 해줌으로써, 서버가 mongo에 연결됨.
```

> db.js 설정

```javascript
//db.js
import mongoose from "mongoose";

mongoose.connect("mongodb://127.0.0.1:27017/wetube", {
  useNewUrlParser: true,
  useUnifiedTopology: true,
});

const db = mongoose.connection;

const handleOpen = () => console.log("Connected to DB ✓");
const handleError = (error) => console.log("DB Error", error);
//on은 여러번 발생 시킬 수 있음 like 클릭이벤트
db.on("error", handleError);
//once는 한번만 발생
db.once("open", handleOpen);
```

### #6.9 CRUD Introduction

- C: Create
  - 유저생성, 비디오업로드, 댓글생성 등
- R: Read
  - 비디오, 검색 등
- U: Update
  - 유저정보 수정, 비디오 수정 등
- D: Delete
  - 회원탈퇴, 댓글삭제 등



### #6.10 VIdeo Model

> 데이터 타입 정하기

- 어떤 유형의 Data를 받는지 정해주기.
- 실제적인 내용을 넣는건 user의 몫

```javascript
//Video.js
import mongoose from "mongoose";

const videoSchema = new mongoose.Schema({
  title: String,
  description: String,
  createdAt: Date,
  hashtags: [{ type: String }],
  // meta는 user가 입력할 필요없음.
  meta: {
    views: Number,
    rating: Number,
  },
});

const Video = mongoose.model("Video", videoSchema);
export default Video;

//server.js
//server.js에 database를 import해서 연결 시킨후,
//해당 연결이 성공적일 때, video를 import해줌.
//db를 mongoose와 연결시켜서 video model을 인식시킴.
import "./db"; //db.js
import "./models/Video";
```



### #6.11 Our First Query

> Server.js와 init.js

- 관련된 것들끼리 역할을 분리시켜줌.
  - sever
    - server의 구성에 관련된 코드만 담기
  - init
    - 필요한 모든 것들을 import 시키는 역할
    - import에 문제가 없다면 app을 실행
- package.json에서 시작 파일을 init.js로 지정.

```javascript
//server.js
import express from "express";
import morgan from "morgan";
import globalRouter from "./routers/globalRouter";
import videoRouter from "./routers/videoRouter";
import userRouter from "./routers/userRouter";

console.log(process.cwd());

const app = express();
const logger = morgan("dev");

app.set("view engine", "pug");
app.set("views", process.cwd() + "/src/views");
app.use(logger);
app.use(express.urlencoded({ extended: true }));
app.use("/", globalRouter);
app.use("/videos", videoRouter);
app.use("/users", userRouter);

export default app;

//init.js
import "./db";
import "./models/Video";
import app from "./server";

const PORT = 4000;

const handleListening = () =>
  console.log(`Server listening on port http://localhost:${PORT} ✓`);

app.listen(PORT, handleListening);
```

> Videomodel 사용

- callback
  - 무언가가 발생하고 난 다음 호출되는 function
  - database는 자바스크립트의 밖에 존재하기 때문에, 약간의 기다림이 필요하다.
  - 기다림을 표현하는 방식
    - app.listen(PORT, handleListening)
      - 연결이 확인되면, handleListening 발동



> Video.find({}) 

- {}는 serch terms,  이게 비어있으면 모든 형식을 찾는다


- logger은 request가 완성되면 출력이 돼야함

- ```javascript
  //videoController.js
  import Video from "../models/Video";
  
  export const home = (req, res) => {
    // find (serch terms, callback(err, documents))
    // {} : search terms가 비어있으면 모든형식을 찾는다는 의미
    Video.find({}, (error, videos) => {});
    return res.render("home", { pageTitle: "Home" });
  };
  ```



### #6.12 Our First Query part Two

> callback

```javascript
Video.find({}, (error, videos) => {});
```

1. mongoose는 {}부분을 database에서 불러온다.
2. database가 반응하면 mongoose는 (error, videos) function을 실행시킨다.

> 출력순서

- 코드에 따라 실행되는 시간이 다를 수 있다.
- 바깥 console.log과 GET request가 끝난 후, video 내부 console.log가 실행되는 모습.

```javascript
export const home = (req, res) => {
  Video.find({}, (error, videos) => {
    console.log("errors", error);
    console.log("videos", videos);
  });
  console.log("hello");
  return res.render("home", { pageTitle: "Home", videos: [] });
};
```

![image-20211224204655529](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211224204655529.png)



### #6.13 Async Await

> callback

- 장점
  - 에러들을 여기에서 바로 볼 수 있음.

```javascript
//videoController.js

// callback 방식
Video.find({}, (error, videos) => {
  if (error) {
    return res.render("server-error");
  }
  return res.render("home", { pageTitle: "Home", videos });
});
```

> promise

- callback의 최신 버전
- async안의 function일때만, await 사용가능

```javascript
//videoController.js

export const home = async (req, res) => {
  /* await가 있으면, find는 callback을 필요로 하지 않는다는 것을 알게됨.
 찾아낸 Video를 바로 출력해줌. 
await는 database를 기다려줌.즉 위의 예시처럼 뒤죽박죽 콘솔로그 되지 않고, 
직관적으로 top to bottom으로 실행됨*/
  const videos = await Video.find({});
  return res.render("home", { pageTitle: "Home", videos });
};
```



### #6.14 Returns and Renders

> return의 역할

- 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.

- return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용render한 것은 다시 render할 수 없음

- redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)



### #6.15 Creating a Video part One

Video 생성

> 정보를 받을 input 생성

```
// upload.pug
extends base.pug

block content
    form(method="POST")
// name이 있어야만, req.body 정보를 받아올 수 있음.
        input(name="title", placeholder="Title", required, type="text")
        input(name="description", placeholder="Description", required, type="text")
        input(name="hashtags", placeholder="Hashtags, separated by comma.", required, type="text")
        input(type="submit", value="Upload Video")
```

> Schema 형태 정해주기

```
//Video.js
import mongoose from "mongoose";

const videoSchema = new mongoose.Schema({
  title: String,
  description: String,
  createdAt: Date,
  hashtags: [{ type: String }],
  meta: {
    views: Number,
    rating: Number,
  },
});

const Video = mongoose.model("Video", videoSchema);
export default Video;
```

> POST 작업시, 작동하는 function 만들기

```
//videoController.js
import Video from "../models/Video";

export const postUpload = (req, res) => {
  const { title, description, hashtags } = req.body;
  const video = new Video({
    title,
    description,
    createdAt: Date.now(),
    //split : , 단위로 스트링을 array로 나누어줌.
    //map : 앞에 #를 붙여줌
    hashtags: hashtags.split(",").map((word) => `#${word}`),
    meta: {
      views: 0,
      rating: 0,
    },
  });
  console.log(video);
  return res.redirect("/");
};
```

### #6.16 Creating a Video part Two

- mongoose가 어느정도 data validation을 하고 있다.
  - 정해준 data type과 다른 정보를 넣으면 출력하지 않음.

> Database에 정보 저장하기

```
//videoController.js

import Video from "../models/Video";

export const home = async (req, res) => {
  const videos = await Video.find({});
  return res.render("home", { pageTitle: "Home", videos });
};
// 방법1. await.video.save()
export const postUpload = async (req, res) => {
  const { title, description, hashtags } = req.body;
  const video = new Video({
    title,
    description,
    createdAt: Date.now(),
    hashtags: hashtags.split(",").map((word) => `#${word}`),
    meta: {
      views: 0,
      rating: 0,
    },
  });
  //database에 저장. await를 함으로써 해당코드가 완료될때까지 기다림.
  await video.save();
  return res.redirect("/");

  //방법2. await Video.create()
  export const postUpload = async (req, res) => {
    const { title, description, hashtags } = req.body;
    await Video.create({
      title,
      description,
      createdAt: Date.now(),
      hashtags: hashtags.split(",").map((word) => `#${word}`),
      meta: {
        views: 0,
        rating: 0,
      },
    });
    return res.redirect("/");
  };
};
```

![12](https://onlee3.github.io/assets/images/wetube/20210706-00012.png)

- 터미널에서 확인이 가능해짐.

### #6.17 Exceptions and Validation

- Error가 발생하는 경우

  - 잘못된 data type 입력

    - number를 요구하는데 string을 입력한 경우

  - required를 요구한 datatype을 입력하지 않은 경우.

    ![13](https://onlee3.github.io/assets/images/wetube/20210706-00013.png)

> try, catch를 이용해 error시 기능 구현

```
//videoController.js
export const postUpload = async (req, res) => {
  const { title, description, hashtags } = req.body;
  try {
    await Video.create({
      title,
      description,
      hashtags: hashtags.split(",").map((word) => `#${word}`),
    });
    return res.redirect("/");
  } catch (error) {
    return res.render("upload", {
      pageTitle: "Upload Video",
      errorMessage: error._message,
    });
  }
};
```

> Schema에서 Default값을 주기

```
//Video.js
import mongoose from "mongoose";

const videoSchema = new mongoose.Schema({
  title: { type: String, required: true },
  description: { type: String, required: true },
  // Date.now()가 아닌 Date.now 를 한 이유: 함수가 바로 실행되는 걸 원하지 않아서.
  createdAt: { type: Date, required: true, default: Date.now },
  hashtags: [{ type: String }],
  meta: {
    views: { type: Number, default: 0, required: true },
    rating: { type: Number, default: 0, required: true },
  },
});

const Video = mongoose.model("Video", videoSchema);
export default Video;
```

### #6.18 More Schema

[Mongoose v5.13.2: SchemaTypes](https://mongoosejs.com/docs/schematypes.html)

- 데이터에 대한 구체적인 설정은 매우 중요함
- minlength, maxlength
  - input과 schema 둘다 설정해두는게 보안에 뛰어남.
- SchemaTypes 예시
  - trim
    - string 양 옆의 빈공간을 없애줌
    - ex) “ h . “””” ⇒ “h .”

> trim, minLength 설정

```
//Video.js
const videoSchema = new mongoose.Schema({
  title: { type: String, required: true, trim: true, maxLength: 80 },
  description: { type: String, required: true, trim: true, minLength: 20 },
  createdAt: { type: Date, required: true, default: Date.now },
  hashtags: [{ type: String, trim: true }],
  meta: {
    views: { type: Number, default: 0, required: true },
    rating: { type: Number, default: 0, required: true },
  },
});
```

> minLength 설정

```
//upload.pug
extends base.pug

block content
    if errorMessage
        span=errorMessage
    form(method="POST")
        input(name="title", placeholder="Title", required, type="text", maxlength=80)
        input(name="description", placeholder="Description", required, type="text", minlength=20)
        input(name="hashtags", placeholder="Hashtags, separated by comma.", required, type="text")
        input(type="submit", value="Upload Video")
```

> video mixin내용 database 내용 표기하도록 변경

```
//video.pug
mixin video(video)
    div
        h4
            a(href=`/videos/${video.id}`)=video.title
        p=video.description
        small=video.createdAt
        hr
```

### #6.19 Video Detail

> 오류1 : upload href 접속시 오류

```
videoRouter.get("/:id(\\d+)", watch);
```

- 현재 mongodb의 id는 문자가 들어간 불규칙한 스트링으로 위의 정규표현식과는 모순되서 오류가 발생한다.

- mongodb의 id는 24글자의 16진수

  [ObjectIds in Mongoose](https://masteringjs.io/tutorials/mongoose/objectid)

> 오류2 : 변수 video가 undefined 상태라 불러올수 없음

```
//watch.pug
extends base.pug

block content
    div
        p=video.description
        small=video.createdAt
    a(href=`${video.id}/edit`) Edit Video &rarr;
```

> 해결1 : URL에 정규표현식, regexpal.com

- [0-9a-f] : 0-9의 숫자 혹은 a-f까지의 문자를 사용하는지 확인(16진수)
- {24} : 24글자로 이루어져있는가?

![14](https://onlee3.github.io/assets/images/wetube/20210706-00014.png)

```
//videoRouter.js
videoRouter.get("/:id([0-9a-f]{24})", watch);
videoRouter.route("/:id([0-9a-f]{24})/edit").get(getEdit).post(postEdit);
```

> 해결2 : findById로 데이타베이스에서 video object 불러오기

- id는 받을 수 있으므로, id를 이용해서 찾기
  - findById
  - 위의 URL 변환 과정을 거쳤으므로, req.params로 URL에서 id를 가져올 수 있는 것.

```
//videoController.js
export const watch = async (req, res) => {
  //해당 URL의 ID를 가져온다.
  const { id } = req.params;
  //ID와 일치하는 video object를 database에서 가져온다.
  const video = await Video.findById(id);
  //video object를 watch.pug로 보낸다.
  return res.render("watch", { pageTitle: video.title, video });
};
```

### #6.20 Edit Video part One

> exec()

- execute를 호출하면 promise가 return 될 것 이다.
- 현재 지워도 상관없는 이유는, async랑 await를 쓰고 있기 때문.

```
//videoController.js
export const watch = async (req, res) => {
  const { id } = req.params;
  const video = await Video.findById(id).exec();
  return res.render("watch", { pageTitle: video.title, video });
};
```

> error 1. (URL에 임의로 id 작성후 접속시)

![15](https://onlee3.github.io/assets/images/wetube/20210706-00015.png)

- 만약 URL에 다른 id를 적어서 접속한다면?
  - ex)localhose4000:/videos/sadasdsa231321asf
- null로부터 title이라는 property를 찾을 수 없음.
  - video 검색에 실패했으므로 null
- 프로그래머는, 계획 외에 실패한 경우도 고려해서 설계해야함

> 해결 1. if를 통해 video가 있는지 확인하고 렌더링

```
//videoController.js
export const watch = async (req, res) => {
  const { id } = req.params;
  const video = await Video.findById(id);
  //new
  if (video) {
    return res.render("watch", { pageTitle: video.title, video });
  }
  return res.render("404", { pageTitle: "Video not found." });
};
//404.pug
extends base.pug
```

> Edit video

```
//videoController.js
export const getEdit = async (req, res) => {
  const { id } = req.params;
  const video = await Video.findById(id);
  // vide===null 인 경우
  if (!video) {
    return res.render("404", { pageTitle: "Video not found." });
  }
  return res.render("edit", { pageTitle: `Edit: ${video.title}`, video });
};
//edit.pug
extends base.pug

block  content
    h4 Change Title of Video
    form(method="POST")
        input(name="title", placeholder="Video Title", value=video.title, required)
        input(name="description", placeholder="Description", required, type="text", minlength=20, value=video.description)
        input(name="hashtags", placeholder="Hashtags, separated by comma.", required, type="text", value=video.hashtags)
        input(value="Save", type="submit")
```

> problem 1 : hashtag가 array형태 그대로 출력됨.

![16](https://onlee3.github.io/assets/images/wetube/20210706-00016.png)

> 해결 1 : join()을 이용해 format 변경

```
input(
  (name = "hashtags"),
  (placeholder = "Hashtags, separated by comma."),
  required,
  (type = "text"),
  (value = video.hashtags.join())
);
```

![17](https://onlee3.github.io/assets/images/wetube/20210706-00017.png)

### #6.21 Edit Video part Two

> POST Request

- 방법 1
  - 직접 값을 변경하고 마지막에 await video.save()로 저장

```
//videoController.js
export const postEdit = async (req, res) => {
  const { id } = req.params;
  const { title, description, hashtags } = req.body;
  const video = await Video.findById(id);
  if (!video) {
    return res.render("404", { pageTitle: "Video not found." });
  }
  video.title = title;
  video.description = description;
  video.hashtags = hashtags.split(",").map((word) => `#${word}`);
  await video.save();
  return res.redirect(`/videos/${id}`);
};
```

> 문제 1 : hashtag #이 무분별하게 붙음

- 단어앞에 무조건 #이 추가되기에, edit할때마다 계속 붙어버림

```
video.hashtags = hashtags.split(",").map((word) => `#${word}`);
```

![18](https://onlee3.github.io/assets/images/wetube/20210706-00018.png)

> 해결 1 : word.startsWith()

- ’#’이 붙으면 word 그대로 출력하고, 없다면 추가함.

```
video.hashtags = hashtags
  .split(",")
  .map((word) => (word.startsWith("#") ? word : `#${word}`));
```

### #6.22 Edit Video part Three

```javascript
export const watch = async (req, res) => {
  const { id } = req.params; 
  //const video = await Video.exists({_id:id});
  const video = await Video.findById(id);
  if(video===null){
    return res.render("404", { pageTitle: "Video not found" });
  }

  return res.render("watch", {pageTitle: video.title, video})
};
```

여기에서는 exist를 사용하면 안됨, object를 edit templete으로 보내줘야함

exist는 그냥 존재여부 확인



### #6.23 Middlewares

> 1. 몽고 사용하기 

>

- mongo

> 2. 내가 가진 db 보기 

>

- show dbs

> 3. 현재 사용 중인 db 확인 

>

- db

> 4. 사용할 db 선택하기 

>

- use dbName
  (현재 수업에서는 `use wetube`)

> 5. db 컬렉션 보기 

>

- show collections

> 6. db 컬렉션 안에 documents 보기        

>

- db.collectionName.find()
  (현재 수업에서는 `db.videos.find()`)

> 7. db 컬렉션 안에 documents 모두 제거하기 

>

- db.collectionName.remove({})
  (현재 수업에서는 `db.videos.remove({})`)

**[몽구스 가이드]** 

- https://mongoosejs.com/docs/guide.html



> Express에서의 middleware

- request를 중간에 가로채서 뭔가를 하고 이어서 진행하는 것
- 뭔가를 하고, next를 콜 한 다음 request를 계속 처리



> mongoose에서의 middleware

- document에 무슨 일이 생기기 전이나 후에 middleware를 적용할 수 있음
- middleware는 무조건 model 이 생성되기 전에 만들어야 함
- this : 우리가 저장하고자 하는 문서



> middleware

- **model이 생성되기 전에 만들어야 함**

- ex)

  ```javascript
  //middleware
  userSchema.pre("save", async function(){  
  
  this.password = await bcrypt.hash(this.password,5);
  
  })
  //model
  const User = mongoose.model("user", userSchema);
  ```

  

**default export는** 

> ```javascript
> import Video, { formatHashtags } from "../models/Video"
> ```
>
> 라고 치면 Video가 defalut export고 {formatHashtags}가 export



### #6.24 Statics

- save hooks 같은 경우는 update할 문서에 접근이 가능함
- findOneAndUpdate의 경우에는 접근할 수 없음

> hashtags array 및 # 문제를 깔끔하게 해결하기

1. findByIdAndUpdate()에서는 save 훅업이 발생하지 않음 => 다른 방법을 알아보자
2. Video.js에 function을 만들어서 관리하기 => 이것도 괜찮음 근데 다른것도 알아보자
3. static을 사용하면 import 없이도 Model.function()형태로 사용이 가능함 => super cool

> 방법 1. 함수를 만들고 export해서 처리

```javascript
//Video.js
export const formatHashtags = (hashtags) =>
  hashtags.split(",").map((word) => (word.startsWith("#") ? word : `#${word}`));
//videoController.js
export const postEdit = async (req, res) => {
  const { id } = req.params;
  const { title, description, hashtags } = req.body;
  const video = await Video.exists({ _id: id });
  if (!video) {
    return res.render("404", { pageTitle: "Video not found." });
  }
  await Video.findByIdAndUpdate(id, {
    title,
    description,
    hashtags: formatHashtags(hashtags),
  });
  return res.redirect(`/videos/${id}`);
};
```

> 방법 2. static

- Video.Create, Video.findById와 같이 우리가 직접 만들 수 있음.

```javascript
//Video.js
videoSchema.static("formatHashtags", function (hashtags) {
  return hashtags
    .split(",")
    .map((word) => (word.startsWith("#") ? word : `#${word}`));
});
//videoController.js
export const postEdit = async (req, res) => {
  const { id } = req.params;
  const { title, description, hashtags } = req.body;
  const video = await Video.exists({ _id: id });
  if (!video) {
    return res.render("404", { pageTitle: "Video not found." });
  }
  await Video.findByIdAndUpdate(id, {
    title,
    description,
    hashtags: Video.formatHashtags(hashtags),
  });
  return res.redirect(`/videos/${id}`);
};
```

> 글에서 hashtags 보이게 수정

- array안의 element 하나하나 ‘hashtags’로 들어가고, li로 정렬되어 촤르륵 나온다.

```javascript
//video.pug
mixin video(video)
    div
        h4
            a(href=`/videos/${video.id}`)=video.title
        p=video.description
        ul
            each hashtags in video.hashtags
                li=hashtags
        small=video.createdAt
        hr
```



### #6.25 Delete Video

> Step 1. watch.pug에서 링크 만들어주기

- URL에 들어가면 지워지게 만들거임.

```javascript
//watch.pug
extends base.pug

block content
    div
        p=video.description
        small=video.createdAt
    a(href=`${video.id}/edit`) Edit Video &rarr;
    br
    a(href=`${video.id}/delete`) Delete Video &rarr;
```

> Step 2. Router 와 Controller 만들기

```javascript
//videoRouter.js
videoRouter.route("/:id([0-9a-f]{24})/delete").get(deleteVideo);
//videoController.js
export const deleteVideo = async (req, res) => {
  // URL에 있는 id를 가져옴
  const { id } = req.params;
  // findOneAndDelete {_id : id} 와 같음
  await Video.findByIdAndDelete(id);
  return res.redirect("/");
};
```

- 특별한 이유가 있지 않은 이상 findByIdAndRemove 대신 findByIdAndDelete를 쓰는 게좋다



### #6.26 Search part One

> 1. 정렬

- mongoose는 굉장히 훌륭한 쿼리엔진을 갖고 있음
  - 문서들을 보여주는 방식을 수정할 수 있다
  - 어떻게 검색하고 정렬할지 정할 수 있음.

```javascript
export const home = async (req, res) => {
  //.sort({}) : 무엇을 기준으로 할지 선택하고 "asc", "desc" 으로 오름차순, 내림차순 결정
  const videos = await Video.find({}).sort({ createdAt: "desc" });
  return res.render("home", { pageTitle: "Home", videos });
};
```

> 1. Search

> globalrouter, videoController 생성

```javascript
//globalRouter.js
globalRouter.get("/search", search);
//videoController.js
export const search = (req, res) => {
  return res.render("search");
};
```

> search.pug 생성

```javascript
//search.pug
extends base.pug

block content
    form(method="GET")
        input(placeholder="Search by title",name="keyword" type="text")
        input(value="Search now", type="submit")
```

- input에 name을 지정해주지 않으면, submit 제출해도 URL에 변화가 없음!

  - *name이 없을때와 있을때 submit 제출결과*

  ![22](https://onlee3.github.io/assets/images/wetube/20210706-00022.png)

  ![23](https://onlee3.github.io/assets/images/wetube/20210706-00023.png)

> form 정보 가져오기

- req.query 안에 keyword 정보가 들어있음

```javascript
export const search = (req, res) => {
  const { keyword } = req.query;
  if (keyword) {
    // serach
  }
  return res.render("search", { pageTitle: "Search" });
};
```

> (req.query와 req.params의 차이?)

- req.query

  Get한 URL에서 q가 가리키는 값을 가져옴

```javascript
/ GET /search?q=tobi+ferret
console.dir(req.query.q)
// => 'tobi ferret'
```

- req.params

  GET한 URL에서 미리 지정해둔 name에 해당하는 URL값을 가져옴

```javascript
// GET /user/tj
console.dir(req.params.name);
// => 'tj'
```



### #6.27 Search part Two

> 검색 기능 만들기

- 밖에서 videos를 선언해주고, 안에서 업데이트 해준다. 그후 search.pug로 videos 정보를 보낸다

```javascript
//videoController.js
export const search = async (req, res) => {
  const { keyword } = req.query;
  let videos = [];
  if (keyword) {
    // title이 keyword가 일치하는 경우를 찾아서 array로 만듬.
    videos = await Video.find({
      title: keyword,
    });
  }
  return res.render("search", { pageTitle: "Search", videos });
};
```

> search.pug 생성

```javascript
//search.pug
extends base.pug
include mixins/video

block content
    form(method="GET")
        input(placeholder="Search by title",name="keyword" type="text")
        input(value="Search now", type="submit")
    div
        each video in videos
            +video(video)
```

> Regular Expression

![24](https://onlee3.github.io/assets/images/wetube/20210706-00024.png)

![25](https://onlee3.github.io/assets/images/wetube/20210706-00025.png)

![26](https://onlee3.github.io/assets/images/wetube/20210706-00026.png)

- ^ : 앞에 오는 단어만 검색
- $ : 마지막 단어만 검색
- i : 대소문자 구분 없앰

> Regular Expression 적용

```javascript
//videoController.js
export const search = async (req, res) => {
  const { keyword } = req.query;
  let videos = [];
  if (keyword) {
    videos = await Video.find({
      title: {
        //keyword를 contain하고 대소문자 구분없이 찾게됨. (mongoDB의 기능)
        $regex: new RegExp({ keyword }, "i"),
      },
    });
  }
  return res.render("search", { pageTitle: "Search", videos });
};
```

> [정규표현식]

- https://www.regexpal.com

> [몽고DB regex]

- https://docs.mongodb.com/manual/reference/operator/query/regex

> [RegExp mdn]

- https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp

> [정규표현식 참고사이트]

- https://wormwlrm.github.io/2020/07/19/Regular-Expressions-Tutorial.html





### # 6.28 Conclusions

- CRUD 완성
- 이 섹션은 Mongoose와 친해지기 위한 목적













## #7.2 Creating Account part Three

[비밀번호 털렸다고? 암호화. 해시함수. 5분 설명 영상]
https://www.youtube.com/watch?v=67UwxR3ts2E

[remove() 명령어 실행이 안될 때] 																			db.users.remove()는 deprecated되었기 때문에 ?
db.users.deleteMany({})로 지우기

[해시함수 테스트]
https://emn178.github.io/online-tools/sha256.html

[패키지 설치]
npm i bcrypt



## #7.3 Form Validation

**$or operator: 조건중 하나만 참이어도 값 가져오기**

```javascript
const exists = await User.exists({$or:[{username},{email}]});
```

몽구스 예전버전은 지원 X



## #7.4 Status Codes

[상태코드]
https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

> \- 200(OK): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
> \- 400(Bad Request): 서버가 요청의 구문을 인식하지 못할 때 발생한다. 클라이언트 측에서 문제가 있을 때 주로 발생한다.
> \- 404(Not Found): 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.



## #7.6 Login part Two

bcrypt가 생성하는 것을 보면 솔트가 해시의 시작 부분에 있음을 알 수 있다

> ex)$2b$**07**$FxSgL.mY0VlBKg0i7Q/Lp.AUciZE./C2UqtFCU93n7ZC7a0e0ge22
>
> =>07, sort 7번



## #7.7 Sessions and Cookies part One

[세션, 토큰, 쿠키 개념 10분 설명 영상]

https://www.youtube.com/watch?v=tosLBcAX1vk 

쿠키 

> 그냥 옮기는 시스템. 매개체

토큰

> 서버가 기억하는 이상하게 생긴 텍스트 

JWT

> 정보를 갖고있는 토큰, DB 없이 검증가능



1. 브라우져 서버에 접근
2. 서버가 브라우져에게 Cookie 준다.
3. 브라우져가 서버에 다시 접근할 때 2.에서 받은 Cookie를 함께 건냄.
4. 서버는 Cookie를 통해 브라우져를 구분 할 수 있다.

**쿠키를 통해 세션ID 전달 O, 세션data 전달 X**



## #7.8 Sessions and Cookies part Two

**세션은 서버측에서 제공해주는 데이터, 쿠키는 클라이언트측에서 저장하고 사용하는 데이터**

req.sessiontStore() 사용했을 때 한번은 undefined가 나온 이유가 세션은 서버에서 만들어줘야 하는데 클라이언트가 첫 요청때 세션을 가지고있을리 없으니 undefined이 나온거고 그 이후 요청부턴 **첫번째 요청 때 세션을 만들어서 넘겨**줬으니 **클라이언트가 해당 값을 쿠키에 저장**하고 매 요청때마다 서버에게 전달
세션은 서버가 만들어서 제공해주다보니 서버가 재부팅되면 초기화 된다. (그래서 DB에 저장해서 관리를 한다는 소리. 실 운영에선 서버가 꺼지는 일은 없으니깐.)
세션의 값은 서버가 만들어주는 고유값이다보니 해당 값을 기준으로 클라이언트에서 요청한 건에 대해 유저를 특정지을 수 있다



즉, 브라우져에서 서버에 로그인 요청을 해서 로그인이 되면 서버는 세션id를 response해주고
브라우져는 쿠키스토리지에 그 세션id를 보관하고 있다가 이후 다시 서버에 방문할 시에는 그 세션
id만 보여주면 자동으로 로그인되게 해줘서 계속 로그인할 수고를 덜어준다는 것이다



## #7.10 Logged In User part Two

res.locals로 저장된 locals변수는 브라우져에 저장되는게 아니라 서버에 저장되는거



## #7.11 Login Recap

**Cookie, Session**

cookie랑 session은 별개의 개념



**cookie**

> 단지 정보를 주고받는일만 한다
>
> cookie의 장점은 자동적으로 처리되는거 사용자는 아무것도 안해도된다
>
> cookie는 sessionID를 저장하고 서버로 전송시켜 backend에도 sessionID를 저장시킨다

> 브라우저는 우리가 매번 backend localhost에 있는 URL로 request를 보낼 때 마다 cookie가 request랑 같이 전송됨 



**Session store**

> session을 저장하는곳



## #7.12 MongoStore

session id는 쿠키에 저장하지만, session데이터 자체는 서버에 저장

서버에 저장되는 default session storage는 MemoryStore이고, 실제 사용하기 위해 있는건 아님

그래서 session을 데이터베이스에 저장해야함

**[connect-mongo] (세션을 몽고디비에 저장)**

npm i connect-mongo

https://www.npmjs.com/package/connect-mongo



**이미 mongoose 가 mongodb 와 연결되어 있는데 connect-mongo 에 dbURL을 전달해 한번더 연결을 하는 이유가 있나요?**

store: MongoStore.create({ client: connection.client })

위와같이 하면 mongoose 의 client 를 사용해서 세션정보를 저장할 수 있는거같습니다

=> 안해봄



## #7.13 Uninitialized Sessions

**[resave, saveUninitialized 참고자료]**

**https://mongojs.tistory.com/26**

**resave(true,false)** 

> session이 store에서 삭제되면 다시 store에 저장될것이냐 

**saveUninitialized : true** 

>  따로 값을 설정하지 않은 전달 받은 날 것의 세션을 즉시 Store에 저장 후 세션 주인에게 쿠키를 (답장하듯) 넘겨 준다.  --> 말 그대로 값이 초기화(initialize)되지 않아도 저장

**saveUninitialized: false** 

>   req.session 속 값을 수정하는 그 순간에 세션을 Store에 저장 후 그제야 쿠키를 전달한다.(backend가 로그인 한 사용자들에게만 쿠키를 주도록 설정) --> 값이 초기화될때 저장

> =>로그인할때 { req.session.loggedIn = true, req.session.user = user} 





session authentication(인증)을 사용하면서 생길 수 있는 문제점?

## #7.14 Expiration and Secrets

쿠키의 프로퍼티에 대해(Name, Value, Domain, Path, Expires / Max-Age, Size, HttpOnly, Secure, SameSite, Priority)

**Secret**

>  쿠키에 sign 할 때 사용하는 string, 쿠키에 sign하는 이유는 backend가 쿠키를 줬다는걸 보여주기 위함, session hijack(납치, 누군가 쿠키를 훔쳐 마치 본인인거처럼 하는것)라는 공격유형을 방어하기 위함 이 string을 가지고 쿠키를 sign하고 우리가 만든것임을 증명하기위해 쓰임

**Domain**

> 이 쿠키를 만든 backend가 누구인지 알려줌

**Path**

> 그냥 url

**Expires**

> 만료날자를 정하지않으면 값이 session으로 돼있는데 사용자가 닫으면 session 쿠키는 끝나게됨, 예를들어 몇몇브라우저에서 프로그램을 닫거나 컴퓨터를 재시작 할 때 이 쿠키는 사라지는거다 (이해가 잘 안됨)

**Max-Age**

> 언제 session이 만료되는지 정하는거에 쓰인다

```javascript
app.use(session({
    secret:"Hello",
    resave:true,
    saveUninitialized: true,
    cookie: {
        maxAge: 20000, // => 20초 뒤에 만료
    },
    store: MongoStore.create({mongoUrl:"mongodb://127.0.0.1:27017/wetube"})
}))

```



## #7.15 Environment Variables

**env파일**

> 모든 API key나 모든 비밀로 해야하는 url을 넣는곳

**evn파일에 접근하는법**

> process.env.variableName

**dotenv**

> env파일을 읽고 각각의 변수들을 process.env안에 넣어준다\



dotenv는 가장 위에 import를 해줘야함, env를 로드하기위해 

import 대신 require("dotenv").config();로 받아오려면 dotenv를 사용하려는 모든 파일의 첫번째에 해줘야한다 너무 비효율적이므로 가장 처음으로 실행되는 파일에 import하자

**npm i dotenv**

https://www.npmjs.com/package/dotenv

import dotenv from "dotenv", dotenv.config() 대신
import "dotenv/config"로 바로 dotenv config함수를 불러와서 실행 가능



## #7.16 ~ 7.21 Github Login

깃허브 OAuth Apps
https://github.com/settings/developers

깃허브 OAuth Apps 공식문서
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps



깃허브로그인 절차

**#1 사용자를 깃허브로 보내기, 우리에게 정보를 공유하는 것을 승인(로그인)**
**#2 깃헙은 사용자를 token과 함께 우리 웹사이트로 redirect 시킴**
**#3 우리는 그 token으로 사용자의 정보를 받아옴 token이 빠르게 만료**



**#1 사용자를 깃허브로 보내기, 우리에게 정보를 공유하는 것을 승인(로그인)**

**GET https://github.com/login/oauth/authorize** 

Parmeters

> client_id: 등록할 때 github에서 받은 클라이언트 ID (required)
>
> redirect_uri string: 승인 후 사용자가 전송될 애플리케이션의 URL
>
> allow_signup(true, false): 인증되지 않은 사용자에게 회원가입 옵션 제공
>
> login: 로그인하고 인증하는데 사용할 특정 계정을 제안(?)
>
> state: .사이트 요청 간 공격으로부터 보호(?)
>
> scope: 유저에게서 얼마나 많이 정보를 읽어내고 어떤 정보를 가져올 것인지
>
> > **read:user** 프로필정보, 만약 read:user를 요청하지 않는다면 user의 정보를 읽을 수 있는 access_token을 받을 수 없다.
> >
> > user:email 이메일주소
> >
> > delete_repo 어떤 repository든 삭제할 수 있다(?)
> >
> > 등등 https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps



github 로그인 창

```javascript
//login.pug
a(href="/users/github/start") Continue with GitHub &rarr;

//userRouter
userRouter.get("/github/start", startGithubLogin);

//githubLogin controller
//#1
export const startGithubLogin = (req, res) =>{
  const baseUrl = "http://github.com/login/oauth/authorize";
  const config = {
    client_id: process.env.GH_CLIENT,
    allow_signup: false,
    scope: "read:user user:email"
  }
  const params = new URLSearchParams(config).toString();
  const finalUrl = `${baseUrl}?${params}`
  return res.redirect(finalUrl);
};
```

=> login.pug에서 controller로 이동 후 github authorize로 redirect

![githubLogin1](https://user-images.githubusercontent.com/48901587/143609971-60950d6a-7d9d-4425-ba51-63d094231b4d.PNG)



**#2 깃헙은 사용자를 token과 함께 우리 웹사이트로 redirect 시킴**

github에서 받은 토큰을 Access토큰으로 바꿔줘야한다.

parameter들과 함께 POST 요청을 해야함 (fetch)

**POST https://github.com/login/oauth/access_token**

Parmeters

> client_id: 등록할 때 github에서 받은 클라이언트 ID (required)
>
> client_secret: 오로지 백엔드에만 존재해야되는 secret, 절대 아무한테도 보여주면 안됨 (required)
>
> code: **#1**에 대한 response로 받은 코드(어느정도 시간이 지나면 만료)



alert가 브라우저에만 존재하고node.js에서 안되는것처럼 fetch도 node.js에 존재하지 않는데 사람들이 node-fetch라는 패키지를 만들었다

node-fetch가 version3을 내면서 이 강의에서 하는 버전과 맞지않아 2.6.1버전을 받아야한다

[패키지 설치]
npm i node-fetch@2.61



```javascript
//githubLogin controller
//#2
export const finishGithubLogin = async (req, res) => {
  const baseUrl = "https://github.com/login/oauth/access_token"
  const config = {
    client_id: process.env.GH_CLIENT,
    client_secret: process.env.GH_SECRET,
    code : req.query.code
  }
 const params = new URLSearchParams(config).toString();
 const finalUrl = `${baseUrl}?${params}`
 const tokenRequest = await (
   await fetch(finalUrl,{
   method: "POST",
   headers:{
    Accept: "application/json",
   },
 })
 ).json();
//fetch를 요쳥하고 fetch가 돌아오면 해당 fetch의 JSON을 받는다
 
```

res.send(JSON.stringify(json)), json으로 토큰을 받아왔다

> ![githubLogin2](https://user-images.githubusercontent.com/48901587/143609986-8c3a4fea-a7d7-4632-b98f-ea87d9980a5b.PNG)



**#3 우리는 그 token으로 사용자의 정보를 받아옴, token이 빠르게 만료**

access_token을 갖고 API에 접근하기, 이제 access_token을 가지고 user의 정보를 얻을 수 있다

```javascript
//githubLogin controller
//#2
export const finishGithubLogin = async (req, res) => {
  const baseUrl = "https://github.com/login/oauth/access_token"
  const config = {
    client_id: process.env.GH_CLIENT,
    client_secret: process.env.GH_SECRET,
    code : req.query.code
  }
 const params = new URLSearchParams(config).toString();
 const finalUrl = `${baseUrl}?${params}`
 const tokenRequest = await (
   await fetch(finalUrl,{
   method: "POST",
   headers:{
    Accept: "application/json",
   },
 })
 ).json();
//#3
 if("access_token" in tokenRequest){//토큰이 있을때
   const {access_token} = tokenRequest;
   //const access_token = json.access_token;
   const userData = await (
       await fetch("https://api.github.com/user",{
    headers: {
      Authorization: `token ${access_token}`//토큰 전달
    }
   })
   ).json();
 console.log(userData);//유저정보 console
 }else{
   return res.redirect("/login")
 }
}
//fetch를 요쳥하고 fetch가 돌아오면 해당 fetch의 JSON을 받는다
```

**유저정보 console**

![githubLogin3](https://user-images.githubusercontent.com/48901587/143609992-5bc27053-f418-4a5e-88c2-c928fffcbf86.PNG)

**access_token**

> **access_token은 user가 모든걸 할 수 있게 해주진 않는다 config의 scope에 명시를 해줘야 github가 code를 주고(req.query.code) 그 코드에는 이미 하고자 하는바가 명시돼있다 그래서 그 코드를 access_token으로 바꾸게되면 access_token은 이미 명시돼있는 일만 하게된다**



**#4 email**

근데 위의 코드들은 scope에서 user:email은 읽어들이지 않고있다

> 위의 console창의 email:null은 기본적으로 read:user로 정보를 가져올 때 email이 private인거, user:email과는 별개

그냥 fetch를 한번 더 사용하면 된다



[user:email scope참고자료]

https://docs.github.com/en/rest/reference/users#emails

> **List email addresses for the authenticated user**
>
> Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
>
> ```
> GET /user/emails
> ```
>
> [Parameters](https://docs.github.com/en/rest/reference/users#list-email-addresses-for-the-authenticated-user--parameters)
>
> | Name       | Type    | In     | Description                                                 |
> | :--------- | :------ | :----- | :---------------------------------------------------------- |
> | `accept`   | string  | header | Setting to `application/vnd.github.v3+json` is recommended. |
> | `per_page` | integer | query  | Results per page (max 100)Default: `30`                     |
> | `page`     | integer | query  | Page number of the results to fetch.Default: `1`            |



```javascript
//#4
   const emailData = await(
     await fetch(`${apiUrl}/user/emails`, {
       headers: {
        Authorization: `token ${access_token}`
       }
     })
   ).json();
   console.log(emailData);
```

**email정보 console**

![githubLogin4](https://user-images.githubusercontent.com/48901587/143609998-306f8277-caed-4d3c-b5ce-448a7b38deb2.PNG)

**#5 email이 verified이면서 primary인 것들을 찾아야한다**

> 이유: 가끔 github으로 계정을 생성해도 primary 혹은 verified가 안되었을 수도 있어서

```javascript
//#5
const emailObj = emailData.find(email => email.primary === true && email.verified ===true)
```



**#6 해당 email을 가진 유저가 이미 있는지 확인 후 있다면 로그인, 없다면 회원가입 후 로그인**

```javascript
//#5
const emailObj = emailData.find(
      (email) => email.primary === true && email.verified === true
    );
    if (!emailObj) {
      return res.redirect("/login");
    }
//#6
    let user = await User.findOne({ email: emailObj.email });
    //console.log("existingUser", existingUser);
    // 해당 이메일을 가진 user가 이미 있는지
    if (!user) {//회원가입
      user = await User.create({
        name: userData.name ? userData.name : "Unknown",
        //github 프로필 설정 안하면 name이 없어서 name path를 찾을 수 없다고 에러나서 예외처리
        username: userData.login,//이게 일반로그인 유저의 username과 겹칠경우도 나중에 고려해야할듯
        email: emailObj.email,
        password: "",
        socialOnly: true,
        location: userData.location,
      } );//로그인
      req.session.loggedIn = true;
      req.session.user = existingUser;
      return res.redirect("/");
    }
```



**#7 logout**

그냥 session을 없애고 홈화면으로 리다이렉트 하면 된다

```javascript
//#7
export const logout = (req, res) => {
  req.session.destroy();
  return res.redirect("/");
}
```





전에 프로젝트 할때 서버랑 데이터 통신하는 fetch사용을 이런 방식으로 then안에서 변수, 함수접근하고 then 안에서 fetch를 한번 더 사용했었다 확실히 아래 코드보다 위의 코드들이 훨신 깨끗하고 알아보기 쉬운거같다

```javascript
//#2, #3
fetch(finalUrl, {
  method: "POST",
  headers: {
    Accept: "application/json",
  },
})
.then((response)=> response.json())
.then((json) => {
  if("access_token" in json) {
    const{ access_token } = tokenRequest;
    const apiUrl = "https://api.github.com";
    fetch(`${apiUrl}/user`, {
      headers: {
        Authorization: `token ${access_token}`,
      },
    })
    .then((response) => response.json())
    .then((josn)=> {
      fetch(`${apiUrl}/user/emails`,{
        headers: {
          Authorization: `token ${access_token}`
        },
      });
    });
  }
});
```



## #8.6 ~ 8.9 File Uploads

multer: 파일을 업로드 할 수 있게 도와주는 middleware
[패키지 설치] 
npm i multer
[참고자료]
https://www.npmjs.com/package/multer

multer는 multipart가 아닌 form을 처리하지 않아서 form에
enctype = "multipart/form-data" 로 encoding type을 multipart/form-data로 바꿔줘야 한다

> form(method="POST", enctype = "multipart/form-data")

**multer기능**

> 1. form으로 보낸 파일 업로드
> 2. 파일명 랜덤생성(같은 이름의 파일을 업로드 해도 문제X)
> 3. 파일을 지정한 폴더에 저장
> 4. 다음 순서의 controller에 파일에 관한 정보 제공



```javascript
#1 middleware
export const avatarUpload = multer({
    dest: "uploads/avatars/", //저장 할 폴더
    limits: {
        fileSize: 3000000,//파일용량제한 3MB
    }
});
#2 view
form(method="POST", enctype = "multipart/form-data")
	label(for="avatar") Avatar 
	input(type="file", id = "avatar", name="avatar", accept="image/*")
#3 userRouter
userRouter
  .route("/edit")
  .all(protectorMiddleware)
  .get(getEdit)
  .post(avatarUpload.single("avatar"), postEdit);
//single: 하나의파일을 업로드, "avatar" input name
```

multer는 input으로 파일을 받아서 그 파일을 uploads 폴더에 저장한 후 그 파일 정보를 postEdit에 전달(req.file)

**참고 : DB에는 파일을 절때 보관하지 않는다(파일의 위치만 저장)**

> 데이터베이스는 엑셀 시트 같은 것이라고 니꼬쌤이 어디선가 설명했었는데, 시트에서도 그렇고, 이번 영상에서도 콘솔상으로도 데이터베이스 출력을 했을 때 이미지는 표시할 수가 없다. 일반적으로는 이미지든 영상이든 뭐든지 다 쌓아놓는곳, 창고 같은 곳 = 데이터베이스라는 인식이 있는데 엄밀하게 말하면 뭐든지 다 쌓아놓는 곳은 하드, 혹은 웹하드, AWS에서는 S3에 해당하는 것이고 데이터베이스는 문자, 테이블, 시트로 표현할 수 있는 것이라고 한다.
>
> 따라서 데이터베이스 자체에는 이미지를 저장할 수 없기 때문에 경로만 저장해두며 해당 경로에 있는 이미지를 별도로 찾게 되는 것이다.
>
> 파일원본은 Amazon의 하드드라이브 같은데 저장하면 된다



**static files serving(폴더 전체를 브라우저에게 노출시킨다)**
[참고자료]
https://expressjs.com/ko/starter/static-files.html

> 브라우저가 서버에 있는 파일에 접근할 수 없으니깐 우리가 브라우저한테 어디로 가야하는지 알려줘야한다 브라우저가 서버의 어떤 폴더로든 갈 수 있다고 생각하면 보안상 좋지않음, 그래서 우리가 브라우저가 어떤 페이지와 폴더를 볼 수 있는지 알려줘야함



```javascript
app.use("/uploads", express.static("uploads"));
```

> express에게 만약 누군가 /upload로 가려고한다면, uploads폴더의 내용을 보여줘라



upload폴더에 사진이 전에 올린 사진들까지 여러가지 저장돼있는 방식의 문제점

> 1. 우리가 파일을 서버에 저장한다는것: 서버는 계속 종료되고 다시 시작하는걸 반복하므로 좋은방법이 아님 뭔가를 업데이트 하면 새로운 서버를 만들어 다시 시작하므로 그 전 서버에 저장돼 있던 파일들은 날아간다
> 2. 서버가 죽었을 때 코드와 업로드된 파일들이 있다면, 파일은 날아간다
>
> 해결방법: 파일을 우리 서버에 저장하는게 아니라 다른곳에 저장하는거로 바꿔 서버가 사라졌다 다시 돌아와도 파일은 그대로 있도록 바꿔야한다 
>
> => 실제 서버에 배포할때 한다고함



## #8.11 ~ 8.13 relationship between user and video

video와 user를 연결해야한다 DB의 id를 가지고 둘을 연결해본다

user에는 해당 user가 업로드한 모든 영상의 id를 저장, video에는 해당 video를 만든 owner 저장

**video에 owner저장**

```javascript
//VideoSchema
owner: { type:mongoose.Schema.Types.ObjectId, required: true, ref:"User"}
//UserModel
const User = mongoose.model("User", userSchema);//"User"이 ref와 연결
//다른 schema의 타입들은 js에서 지원하는건데 ObjectId는 mongoose의 스키마타입, ref는 ObjectId가 model user에서 온다고 알려주는거
```

이제 video를 업로드 할 때 owner에 _id를 추가해주면된다.

**populate**

> ref(reference):"User" 가 videoSchema와 userSchema를 연결해줘 한번에 비디오와 그 비디오의 owner를 찾을 수 있다.
>
> ```javascript
> //populate 사용
> //videoController
> const video = await Video.findById(id).populate("owner");
> //populate("schema의 속성이름")
> 
> //populate하기 전 video의 owner
> owner: new ObjectId("61a773af49cb2c1e6dea986a"),
> //populate후 video의 owner
> owner: {
> _id: new ObjectId("61a773af49cb2c1e6dea986a"),
> email: 'rladbrua0207@gmail.com',
> avatarUrl: 'https://avatars.githubusercontent.com/u/48901587?v=4',
> socialOnly: true,
> username: 'rladbrua0207',
> password: '$2b$05$TBMhdTVXJ1l5b19Y6AiC..ahdiOrmOi5kgNb2aUlP8JB1ztjJ.kce',
> name: 'Unknown',
> location: null,
> __v: 0
> },
> ```
>
> populate를 사용 안하면
>
> ```javascript
> //video에 저장돼있는 owner의 id를 통해 다시 DB에 접근을 해 user정보를 가져와야한다
> const owner = await User.findById(video.owner);
> ```





**user에  본인video저장**

> user의 videos속성에 새로운 videoId 저장

```javascript
//UserSchema
videos: [{type: mongoose.Types.ObjectId, ref: "Video"}]
//videos는 Video model에 연결된 ObjectId로 구성된 array

//videoContorller create video 
const user = await User.findById(_id);// _id: userId
user.videos.push(newVideo._id); //생성된 비디오의 id를 usermodel에 저장
user.save(); 
//user.save()를 할 경우 userModel에서 password가 두번 hash됨 이 문제는#8.14에서 다룸
```

> video는 여러 owner를 가질 수 있는데 owner는 여러 video를 가질 수 없으므로 type:array

**populate**

> populate를 어디에 스고 안 쓸지를 잘 생각해봐야함 필요없는 데이터를 굳이 populate를 써서 로드할 필요는 없음 안써도 된다면 안쓰고 해결

```javascript
//populate 사용
//userController
const user = await User.findById(id).populate("videos");
//populate("schema의 속성이름")
//populate하기 전 user의 videos
videos: [ new ObjectId("61a796974b50374ed2701092") ]
//populate후 user의 videos
videos: [
    {
      meta: [Object],
      _id: new ObjectId("61a796974b50374ed2701092"),
      title: 'bunny',
      fileUrl: 'uploads\\videos\\78da92bba8a27f0aab86a67bc5acb7de',
      description: '123451234512345123451234512345',
      hashtags: [Array],
      owner: new ObjectId("61a7966e4b50374ed270108f"),
      createdAt: 2021-12-01T15:36:55.995Z,
      __v: 0
    }
  ],
```





## #8.14 Bugfix

**password가 user.save() 할 때마다 hash 되는 문제**

```javascript
//password가 수정됐을 경우에만 hash되게
userSchema.pre("save", async function () {
  if (this.isModified("password")) {//isModified: 수정이됐을경우 true
    this.password = await bcrypt.hash(this.password, 5);
  }
});
```



**video edit form이 모든사람에게 나타나는 문제**

```javascript
//영상의 주인이 아니면 이 페이지에 접속 못하게
export const getEdit = async (req, res) => {
  const {
    params:{ id },
    session:{user: {_id}}
  } =req;
  const video = await Video.findById(id);
  if(!video){
    res.status(404).render("404", { pageTitle: "Video not found" });
  }
  if(String(video.owner) !== String(_id)){//요기
    return res.status(403).redirect("/");
  }
  res.render("edit", { pageTitle: `Edit ${video.title}`, video});
};
//postEdit, deleteVideo에도 같은방법 적용
```



**deleteVideo 에서 Video db는 지워졌지만, User db에 videos가 남아있는 문제 (강의X)**

```javascript
//splice로 삭제
export const deleteVideo = async (req, res) => {
const { id } = req.params;
const {
user: { _id },
} = req.session;
const video = await Video.findById(id);
const user = await User.findById(_id);
if(!video){
return res.status(404).render("404", { pageTitle: "Video not found." });
}
if (String(video.owner) !== String(_id)) {
return res.status(403).redirect("/");
}

await Video.findByIdAndDelete(id);
user.videos.splice(user.videos.indexOf(id),1);//요기
user.save();
return res.redirect("/");
}
//splice참고 https://im-developer.tistory.com/103
```





## #9.0 ~ 9.7 Webpack



Webpack은 .jpg 같은 거는 압축된 jpg 를 주고, JS 는 오래된 버전의 JS로, Sass 는 못생긴 css 로 준다. 압축, 변형, 최소화등 필요한 작업들을 거치고 정리된 코드를 결과물로 준다.

[웹팩의 기본 개념 참고]
https://jeonghwan-kim.github.io/js/2017/05/15/webpack.html

[webpack, webpack-cli을 devDependencies 로 설치]
npm i webpack webpack-cli -D

Webpack 시작하기: https://webpack.kr/guides/getting-started/
Webpack 설정: https://webpack.kr/concepts/configuration/

Webpack CLI를 이용해서 콘솔에서 Webpack을 불러낼 수 있다.

webpack.config.js 

> 이 파일에서 webpack 환경설정. 
>
> Webpack이 읽을 configuration 파일을 내보낸다
>
> 이 파일에서는 오래된 javascript 코드만 이해할 수 있다.

중요한 거 두 가지(필수 설정)

> \- entry: 우리가 처리하고자 하는 파일들(예쁜 js)
> \- entry: 이 프로퍼티에 우리가 처리하고자 하는 파일의 경로 입력
> \- output: 결과물
> \- filename: 이 프로퍼티에 우리 결과물이 될 파일 이름 입력
> \- path: 이 프로퍼티에 우리 결과물 파일을 어디에 저장할 지 지정 (이 경로는 절대경로여야 해!)



**__dirname(directory name)**

> 말 그대로 파일까지의 경로 전체 자바스크립트가 제공하는 상수

**path.resolve()**

> 몇 개가 됐든 입력하는 파트들을 모아서 경로로 만들어주는 메서드
>
> ```javascript
> const path = require("path");
> console.log(path.resolve(__dirname, "assets", "js"));
> // => 현재경로/assets/js
> ```

**rules**

> 각각의 파일 종류에 따라 어떤 전환을 할 건지 결정



**babel-loader**

> [babel-loader 설치]
> npm install babel-loader -D
> https://github.com/babel/babel-loader
>
> webpack loader
> https://webpack.kr/loaders/
>
> webpack babel-loader
> https://webpack.kr/loaders/babel-loader/

[main.js에 빈 파일 나오는 오류]

> mode를 설정해주지 않으면 기본적으로 production으로 설정되어 client/js폴더 내에 작성한 main.js를 변환했을 때, 빈 파일로 나올 수 있다
> 빈 파일 나오면 module.export안에 mode: "development"로 설정



**client폴더는 코딩할 폴더(webpack이 처리하기 전), assets폴더는 브라우저가 접근해서 볼 폴더(webpack이 실행되고 난 다음 만들어진 파일)**



**server.js에서 express한테 사람들이 asset폴더를 볼 수 있게 요청을해야함(uploads폴더 랑 같음)**

```javascript
app.use("/assets", express.static("assets"));
// =>app.use("/url이름", express.static("assets"));
//url이름을 폴더명과 다르게 바꿔도 된다
```



**scss**

> scss는 loader가 3개 필요함, webpack의 순서
>
> 1. scss를 일반 css로 변형할 loader
> 2. 폰트불러올때 css에 쓰일 loader
> 3. 변환한 css를 웹사이트에 적용시킬 loader
>
> ```javascript
> use: ["style-loader", "css-loader", "sass-loader"]
> //제일 마지막에 있는 loader가 webpack이 제일 먼저 사용할 loader
> ```
>
> [sass, sass-loader, css-loader, style-loader 설치]
>
> npm i sass sass-loader css-loader style-loader -D
>
> [참고자료]
> https://github.com/webpack-contrib/sass-loader
> https://www.npmjs.com/package/css-loader
> https://webpack.js.org/loaders/style-loader/#root



**css파일 분리하기**

> MiniCssExtractPlugin
> npm install --save-dev mini-css-extract-plugin
> https://webpack.kr/plugins/mini-css-extract-plugin/
>
> CssMinimizerWebpackPlugin
> https://webpack.kr/plugins/css-minimizer-webpack-plugin/
>
> ```javascript
> //import
> const MiniCssExtractPlugin = require("mini-css-extract-plugin");
> //module.exports
> plugins: [new MiniCssExtractPlugin()],
> //rules
> use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
> ```
>
> 



**watch: true**

자동으로 webpack에서 js, css가 변경되는지 확인 후 적용



프론트의js가 변경될때 백에서도 재시작되는거 막으려면
=> nodemon에게 몇가지 파일이나 폴더들을 무시하는 방법을 알려줘야함

> nodemon.json파일을 만든 후
>
> ```javascript
> //nodemon.json
> {
> "ignore": ["webpack.config.js", "src/client/*", "assets/*"],
> "exec": "npx babel-node src/init.js"
> }
> //package.json
> "scripts": {
>   "dev": "nodemon",  
>   "assets": "webpack --config webpack.config.js"
> },
> //dev를 nodemon으로 짧게 바꿈
> ```



## #10 styles

header, footer, 등 partials, mixin: components폴더에 componets파일 만들기

home, search, join, login 같은 template: (URL같은거) screen폴더에 screen파일 만들기



## #12 Views API

템플릿을 랜더링하지 않는 views : api views, 대부분의 인터넷이 이렇게 작동
요즘은 거의 CSR사용

API는 프론트엔드와 백엔드가 서버를 통해 통신하는 방법을 말함

```javascript
//client/js/videoPlayer
const handleEnded = () =>{
  const {id} = videoContainer.dataset;
  fetch(`/api/videos/${id}/view`, {
    method: "POST",
  });
//비디오가 끝났을 때 POST요청
};
video.addEventListener("ended", handleEnded);

//server
import apiRouter from "./routers/apiRouter";
app.use("/api", apiRouter);
//apiRouter
import express from "express";
import { registerView } from "../controllers/videoController";

const apiRouter = express.Router();
apiRouter.post("/videos/:id([a-f0-9]{24})/view", registerView);

export default apiRouter;


//videoController
export const registerView = async (req, res) => {
  const {id} = req.params;
  const video = await Video.findById(id);
  if(!video){
    return res.sendStatus(404);
  }
  video.meta.views = video.meta.views +1; //조회수 +1
  await video.save();
  return res.sendStatus(200);
}//return res.status로하면 의미 X(pending상태)
```



**[dataset]**

https://developer.mozilla.org/ko/docs/Learn/HTML/Howto/Use_data_attributes

HTML문법

> ```html
> <article
> id="electriccars"
> data-columns="3"
> data-index-number="12314"
> data-parent="cars">
> ...
> </article>
> ```

JavaScript에서 접근

> ```javascript
> var article = document.getElementById('electriccars');
> article.dataset.columns // "3"
> article.dataset.indexNumber // "12314"
> article.dataset.parent // "cars"
> ```



**상태코드**

```javascript
//상태코드를 리턴해줄 때 render같은것을 써줘야 의미가 있다
return res.status(404);//의미X(pending)
return.res.sendStatus(404)
```



## #13 Video Recoder

[MediaDevices.getUserMedia()]

https://developer.mozilla.org/ko/docs/Web/API/MediaDevices/getUserMedia



프론트에서 async, await를 사용하려면 regeneratorRuntime를 설치해야한다

[regeneratorRuntime설치]

npm i regenerator-runtime



```javascript
const startBtn = document.getElementById("startBtn");
const video = document.getElementById("preview");
let stream;
let recorder; 
let videoFile;
const handleDownload = () =>{
    const a = document.createElement("a");
    a.href = videoFile;
    a.download = "MyRecording.webm";
    document.body.appendChild(a);//body에 존재하지 않는 링크는 클릭 할 수 없기때문에 추가
    a.click();
}
const handleStop = () =>{
    startBtn.innerText= "Download Recording";
    startBtn.removeEventListener("click", handleStop);
    startBtn.addEventListener("click", handleDownload);
    recorder.stop();
}
const handleStart = () => {
    startBtn.innerText = "Stop Recording";
    startBtn.removeEventListener("click", handleStart);
    startBtn.addEventListener("click", handleStop);
    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = (e) => {
        videoFile = URL.createObjectURL(e.data);//브라우저가 파일에 접근할 수 있는 URL
        video.srcObject = null; //비디오의 미리보기 제거(?)
        video.src = videoFile;
        video.loop = true; //반복재생
        /*
        왜 video.srcObject로 안하나 했는데 MDN에서 지금 한 방법은 옛날방법이라고 한다.
        
        ex) 옛날방식
        const mediastream = await navigator.mediaDevices.getUserMedia({video: true});
        const video = document.createElement("video");
        video.srcObject = mediaStream;
        요즘방식
        const mediaSource = new MediaSource();
        const video = document.createElement("video");
        video.srcObject = mediaSource
        */
        video.play();
    }
    recorder.start();
};
const init = async() =>{
    stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: true,
    })
    video.srcObject = stream; //video 태그
    video.play();
}
init();
```



ondataavailable

> 녹화가 멈추면 발생되는 이벤트
>
> ondataavailable 이벤트 핸들러의 인자로 전달되는 event 객체에는 data 속성이 있으며, source에서 생성되는 Blob 형의 데이터를 참조하고 있다



createObjectURL

> 브라우저 메모리에서만 가능한 URL 만들어줌



## #14 WebAssembly Video Transcode

(이챕터는 나중에 따로 들을거)

**웹어셈블리 참고영상**

https://www.youtube.com/watch?v=KjgDxBLv0bM

폴더와 파일이 있는 가상의 컴퓨터를 브라우저에서 실행

**FFmpeg**

> 비디오를 압축하거나 비디오 포맷을 변환하거나 비디오에서 오디오 추출, 비디오에서 스크린샷, 비디오를 여러가지 포맷과 화질로 인코드 등등 여러가지 할 수 있음
>
> 무겁고, 보통은 백엔드에서 사용하지만 webassembly덕분에 프론트엔드에서도 사용 가능

**WebAssembly**

> 웹사이트가 매우 빠른 코드를 실행할 수 있게 해줌(Javascript를 사용하지 않고, 다른 종류의 프로그램 사용)

사용자의 브라우져에서 비디오 변환

FFmpeg와 WebAssembly를 결합한 ffmpeg.wasm을 사용

**ffmpeg.wasm**

> 비디오를 변환하기 위해 사용자의 컴퓨터 사용(서버에서 변환하는건 돈들음)



패키지 다운로드
npm i @ffmpeg/ffmpeg @ffmpeg/core

버전 에러때문에

npm install @ffmpeg/core@latest 설치하고
recorder.js 에
const ffpmeg = createFFmpeg({
corePath: 'https://unpkg.com/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js',
log:true
});
로 수정

참고사이트
https://www.npmjs.com/package/@ffmpeg/ffmpeg



또 버전에러를 해결하니깐 이번엔 영상을 다운로드할 때 
Uncaught (in promise) ReferenceError: SharedArrayBuffer is not defined 라는 에러가 뜬다 이거를

```javascript
//server 
app.use((req, res, next) => {
res.header("Cross-Origin-Embedder-Policy", "require-corp");
res.header("Cross-Origin-Opener-Policy", "same-origin");
next();
});
```

ffmpeg 사용 당시 부딪힌 sharedArrayBuffer 에러를 해결하러면 이 header를 설정해줘야 한다 근데 여기서 배포할때 보면 비디오랑 프로필사진 로드가 안된다 이건 #17에서 확인



## #15 Falsh Messages

express-flash

> 템플릿에다 사용자에게 메시지를 남길 수 있게 해주는 미들웨어, 이 메세지는 session에 있어 한 사용자만이 볼 수 있다
>
> [패키지설치]
>
> npm i express-flash
>
> ```javascript
> //이 패키지를 설치하므로 req.flash()를 사용할 수 있고, messages locals를 만들어줘 view에서 사용할 수 있다.
> //server
> import flash from "express-flash";
> app.use(flash());
> //ex) 로그인안한 사용자 막는 middleware
> export const protectorMiddleware = (req, res, next) => {
> if(req.session.loggedIn){
>   return next();
> }else{
>   req.flash("error", "Not authorized");// 타입, 메세지
>   return res.redirect("/login");
> }
> };
> //메시지가 한번 view에서 보여지면 express가 메시지를 cache에서 지워서 한번만 보여질 수 있다.
> ```
>
> 



## #16 Comment Section

**express.json()**

> express의 string을 받아서 json으로 바꿔주는 middleware

```javascript
//server
app.use(express.json());

//videoController.js
return res.Status(201).json({newCommentId: comment._id});//response로 commentId 보내는법

//commentSection.js
//header은 기본적으로 request에 대한 정보를 담고있다.
    const response = await fetch(`/api/video/${videoId}/comment`,{
    //{status} = ~~~
        method:"POST",
        headers:{
            "Content-Type" : "application/json",
        },
        body: JSON.stringify({
            text,
        }),
    });
    textArea.value = "";
    const json = await response.json();//
    if(response.status === 201){
        addComment(text);
    }
```

1. fetch로 백엔드에 요청을 보낼 때에
   method: "POST",
   headers: {},
   body: {},

   URL과 더불어 이 세 가지를 덧붙여야 한다.

2. headers에는 이 요청의 세부 사항을 명시하며, body에는 실질적인 컨텐츠가 포함된다.

3. 따로 명시하지 않을 시에 모든 body의 컨텐츠는 Text File로서 전송되고 받아 인식된다.

4. 특히 body: { ... }, 이런 식으로 자바스크립트 오브젝트를 넘겨줄 시 외부에서 이 오브젝트는 [object Object]라는 의미 없는 문자열로 변환된다.

5. 오브젝트와 그 안의 세부 변수 목록들을 넘겨주고 싶을 시, JSON이라는 규약에 의거한 오브젝트 내의 모든 기록을 텍스트화하여 넘겨주어야 하는데, 이때 JSON.stringify({ ... }) 라는 편리한 자체 표준 함수를 사용하면 된다.

6. 덧붙여 headers 안에 "Content-Type": "application/json"이라는 명시를 해 주어 전송된 텍스트가 JSON파일임을 백엔드에 인식시켜 준다.

7. 백엔드에 (이를테면 express를 사용 중이라면) app.use(express.json()); 미들웨어를 추가해주어 자체 내에서 JSON.parse("..."); JSON파일을 다시 자바스크립트 오브젝트로 변환해주는 표준 함수로 요청 body 내의 컨텐츠를 디코딩하는 작업을 한다.

8. fetch를 할 경우 여느 때와 똑같이 브라우저는 쿠키를 함께 전송한다.



## #17 DEPLOYMENT

**Heroku를 통해 배포**

어떤 node.js 환경에서도 서버가 실행될 수 있게 설정을 바꿔야함

> DB, Amazon Web Services, 코드를 production방법으로 빌드, 코드압축 등등 해야함



babel-node는 실제로 서비스 되는 곳이 아니라 개발할 때만 사용되는 목적으로쓰임 바벨노드는 ES6이상에서 사용되는 자바스크립트 코드를 실행할 수 있게 도와주지만 성능문제가 있음(bavel-node는 느림)

그래서 init.js를 일반적인 javascript 코드로 바꿔야함
=> Babel CLI

Babel CLI

> https://babeljs.io/docs/en/babel-cli
> npm install --save-dev @babel/core @babel/cli

```javascript
//package.json
"scripts": {
        "build:server" : "babel src -d build",
//src를 bulid, -d 로 특정directory 지정(build)
    },
//server
app.set("views", process.cwd() + "/src/views");
```

babel이 src 폴더를 빌드하고 결과물을 build 폴더에 저장,

build를 해도 views 파일은 안넘어감 근데 server에 view를 설정하는 부분에서 process.cwd()가 package.json을 갖고있는 root폴더를 가리킴 그래서 굳이 view가 안넘어가져도 랜더링이 잘됨

그래서 빌드서버는 환경변수(env)에 접근할 수 있다



**webpack의 두가지모드**

development, production

webpack.config.js의 mode: "development", watch:true 를 적지않고 webpack을 실행할 때 적용

development

> ```javascript
> //package.json
> "dev:assets": "webpack --mode=development -w"
> //-w : watch:true => client파일 변경될때마다 webpack이 assets파일로 번역
> ```

production

> ```javascript
> //package.json
> "build:assets": "webpack --mode=production"
> ```
>
> 그냥 assets파일이 다 한줄로 바뀜



**heroku Git으로 배포**

Heroku CLI 설치

> https://devcenter.heroku.com/articles/heroku-cli

heroku login을 치면 

heroku: Press any key to open up the browser to login or q to exit: 라는게 나와야하는데 cmd에서만 나오고 powershell에서는 안나와서 알아보다가 powershell에서 Set-ExecutionPolicy RemoteSigned해주니깐 됐다

> 참고사이트:https://cloudsns.wordpress.com/2012/07/04/set-executionpolicy%EC%9D%98-remotesigned%EC%9D%98-%EC%9D%98%EB%AF%B8/

heroku는 오직 git history만 봄 commit 필수

**heroku logs --tail**

> 실시간서버log보여줌

**heroku연결**

> heroku git:remote -a "app이름"
>
> push 할때는 git push origin main && git push heroku main 
>
> 내 깃 저장소랑 heroku에 같이 푸시 
>
> => 안되네  그냥 따로따로 푸시

**mongoDB Atals**

연결방법: MongoDB's native drivers로

**DB_URL 설정**

> heroku admin panel이용
>
> : heroku앱 => Settings =>  Reveal Config Vars에
>
> key: DB_URL
>
> value: Mongo Atals에서 받은 url
>
> COOKIE_SECRET도 같은방법으로
>
> 근데 왜 process.env.DB_URL, process.env.COOKIE_SECRET 이렇게 적었는데 되는거지??
>
> 그냥 process.env가 접근방법인가보다
>
> ```javascript
> //server.js
> secret:process.env.COOKIE_SECRET
> //db.js
> mongoose.connect(process.env.DB_URL, {
> useNewUrlParser: true,
> useUnifiedTopology: true,
> });
> ```

**Heroku는 자동으로 npm run build 후 package.json에 있는 모든걸 설치하고 npm start를 한다**  

> 이거 진짜 중요 패키지설치할때 --save 안해주고 그냥했을때 package.json에 dependencies로 안들어가면 노드모듈을 못읽음

Heroku는 랜덤으로 port를 줌

```javascript
//init.js
const PORT = process.env.PORT || 4000;
```



**Github을 통해 배포**

그냥 push만 해주면 자동으로 배포



**AWS**

client

1. buket 만들기

   Storage => S3 => Create bucket 

2. API key 만들기

   그래야 node.js 코드가 AWS와 통신가능

   service => IAM => Users => Add users => check Programmatic access(로그인할때 access key 사용) => check AmazonS3FullAccess => next: Tags => Create user => Access key ID, Secret access key 가 뜨는데 단 한번만 보여줌 => env파일에 저장, heroku var에 저장

3. Multer S3 패키지 사용

   https://www.npmjs.com/package/multer-s3

   npm i --save multer-s3

   +aws 패키지 설치

   npm i aws-sdk

   Multer S3는 Multer를 사용할 수 있게 도와줌

   upload 할때 ex) video, avatar  두가지를 변경해야함

   ```javascript
   //middlewares.js
   import multer from "multer";
   import multerS3 from "multer-s3";
   import aws from "aws-sdk";
   
   const s3 = new aws.S3({
     credentials: {
       accessKeyId: process.env.AWS_ID,
       secretAccessKey: process.env.AWS_SECRET,
       //heroku에도 같은 변수명
     },
   });
   
   const multerUploader = multerS3({
     s3: s3,
     bucket: "gyeomtube", //bucket이름
   });
   
   export const avatarUpload = multer({
     dest: "uploads/avatars/",
     limits: {
       fileSize: 3000000,
     },
     storage: multerUploader,
   });
   
   export const videoUpload = multer({
     dest: "uploads/videos/",
     limits: {
       fileSize: 10000000,
     },
     storage: multerUploader,
   });
   //storage 추가
   ```



세가지문제 

1. object가 비공개인거

   => s3 => permissions

   ![image-20211214185630027](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211214185630027.png)	

2. Access Control List 전달

   ACL은 기본적으로 object의 권한

   bucket 밑에 acl: "public-read", 써주기(안써주면 사진로드 X 안써줘서 계속 헤맴,,)

3. file을 받아올때 file.path로 받아왔었는데 이제는 AWS으로 업로드 돼 file.location으로 접근해야한다



**Production Environment**

heroku에서 작업할땐 multer uploader만 사용

> process.env.NODE_ENV (heroku에서만 읽을수있음)
>
> =>"production"

local에서 작업할땐 파일 시스템을 uploader만 사용하도록

=> multer uploader 를 2개 만들어야함

```javascript
const isHeroku = process.env.NODE_ENV === "production";

const s3 = new aws.S3({
  credentials: {
    accessKeyId: process.env.AWS_ID,
    secretAccessKey: process.env.AWS_SECRET,
    //heroku에도 같은 변수명
  },
});
const s3ImageUploader = multerS3({
  s3: s3,
  bucket: "gyeomtube/images", //bucket이름
  acl: "public-read",
});

const s3VideoUploader = multerS3({
  s3: s3,
  bucket: "gyeomtube/videos", //bucket이름
  acl: "public-read",
});
export const avatarUpload = multer({
  dest: "uploads/avatars/",
  limits: {
    fileSize: 3000000,
  },
  storage: isHeroku ? s3ImageUploader : undefined,
});

export const videoUpload = multer({
  dest: "uploads/videos/",
  limits: {
    fileSize: 10000000,
  },
  storage: isHeroku ? s3VideoUploader : undefined,
});//heroku일때만 s3사용

//dest가 multer uploader에서 작동안하므로 2개를 따로 만들어야함
```



Object업로드할때 원래있던 오브젝트가 있으면

https://velog.io/@nawnoes/Nodejs-aws-sdk-S3-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%82%AD%EC%A0%9C

여기 참고해서 오브젝트 삭제







전에 WebAssembly 에서

```javascript
//server 
app.use((req, res, next) => {
res.header("Cross-Origin-Embedder-Policy", "require-corp");
res.header("Cross-Origin-Opener-Policy", "same-origin");
next();
});
```

를 했었는데 이 설정때문에 비디오랑 프로필사진이 로드가 안된다 

보안적인문제?라고 FFmpeg모듈이 실행될때 다른도메인에서 오는 URL은 보안상 허용하지 않는다고 한다

그래서 다 지워버리고 그냥

```javascript
//##1
//server
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "X-Requested-With");
  res.header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
  next();
});
```

이렇게 모두가 허용되도록 바꿔줬는데

안돼서 다시
https://onlee3.github.io/clonecoding/wetubeC17/ 여기를 참고해서

```javascript
//##2
//server.js
app.use((req, res, next) => {
  res.header("Cross-Origin-Embedder-Policy", "require-corp");
  res.header("Cross-Origin-Opener-Policy", "same-origin");
  next();
});
//pug에 AWS에서 받아오는것들에 crossorigin추가
//videoControlles.js
//upload창에서 ffmpeg와 충돌이 나므로 header 추가
export const getUpload = (req, res) => {
  res.header("Cross-Origin-Embedder-Policy", "require-corp");
  res.header("Cross-Origin-Opener-Policy", "same-origin");
  return res.render("upload", { pageTitle: "Upload Video" });
};
//위에 참고사이트에서는 getupload에 header를 추가해주는데 어차피 getupload를 router에서 부르기 전에 server에서 위의 middleware를 호출해서 header를 설정할탠데 왜 getupload에서 또 설정해주는지 모르겠다 그래서 내 코드에서는 뺐다
```

이렇게 해주니깐 한번에 되는게 아니고 서서히? 됐다

근데?? 전에 했던 ##1 이 왜 안되나 싶어서 전에거 지우고 다시 ##1로 해봤는데?? 이번엔 됐다 대체 뭔지 모르겠다 대체 왜 되는거지???? 진짜 왜 안됐다가 되는지 모르겠다 안돼서 AWS에서도 CORS 설정하는게 있길래 그거도 설정 해봤다 이거는 왜하는건지 모르겠다 원래 서버에서만 CORS를 설정하는거라고 알고있는데 일단은 했다 구글링해도 왜 하는건지는 모르겠다..

또 header를 지워서 오류나게했다가 다시 header를 추가했는데 또 오류가 나온다 이게 좀 시간이 걸리는가보다



```javascript
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "X-Requested-With");
  res.header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
  next();
});
//이거로 하면 pug에 AWS에서 파일 받아오는 태그들에 crossorigin을 빼야만 cors오류가 안난다 대신 ffmpeg 사용 당시 부딪힌 sharedArrayBuffer 에러를 해결하려고 설정한 Cross-origin 세팅을 바꾼거여서 sharedArrayBuffer오류가 난다 그래서 다시//##1로 변경했다
```

**AWS s3 CORS 설정**

참고사이트: https://velog.io/@kimsehwan96/S3-CORS-%ED%97%A4%EB%8D%94-%EA%B4%80%EB%A0%A8-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-html2canvas-lottie 

```
[
    {
        "AllowedHeaders": [
            "*"
        ],
        "AllowedMethods": [
            "GET",
            "HEAD"
        ],
        "AllowedOrigins": [
            "*"
        ],
        "ExposeHeaders": [
            "x-amz-server-side-encryption",
            "x-amz-request-id",
            "x-amz-id-2"
        ],
        "MaxAgeSeconds": 3000
    }
]
```

❕❕ 알게된사실 ##1처럼 하면 AWS s3 에서 CORS 설정을 안해도 파일이 가져와지는데 ##2처럼 하면 AWS s3에서 CORS 설정을 해줘야 파일이 가져와진다 왜 이런진 모르겠다,,

그리고 위의 ##2 에서 cors오류가 서서히 해결 됐다고 했는데 그게 아니었다 이미 cors를 설정하기 전에 올렸던 파일들 때문에 어떤건 되고 어떤건 안돼서 그렇게 느낀거 같다

ffmpeg충돌만 아니라면 그냥 ##1처럼 하는게 간단하고 AWS에서도 CORS 설정을 굳이 할 필요가 없는거같다 근데 또 ##1처럼 하는거는 보안에 안좋다고하기도 해서 뭐가 더 좋은방법인지는 모르겠다 .





