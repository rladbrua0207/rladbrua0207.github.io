---
title:  "YouTube 클론코딩"
excerpt: "#3 express, #4 routers, #5 templates, #6 mongoDB and mongoose, #7 user authentication, #8 user profile, #9 webpack, #10 styles"
date:   2021-12-16 23:20:32 +0900
categories: web
tags:
  web
  javascript
  node.js	
  mongoDB
toc: true
toc_sticky: true


---



## #2 SET UP

babel을 이용해 최신 문법코드를 쓸 수 있다 https://babeljs.io/

=> 최신문법코드를 node.js가 이해할수있게 번역

babel, config.json이란 babel이 알아서 이 파일을  찾고 내용을 들여다본다 

preset은 babel을 위한 플러그인 preset-env가 유명(최신 자바스크립트 구문을 사용할 수 있게 해줌)

"scripts":{"dev": "babel-node index.js"} : node.js가 실행되는데 babel도 적용돼서 실행



nodemon은 우리가 만든 파일이 수정되는걸 감시해주는 패키지

파일이 수정되면 nodemon이 알아서 재시작

[노드몬 설치]

 npm i nodemon --save-dev



```javascript
"scripts":{"dev": "nodemon --exec babel-node index.js"}
```

'babel-node'은(는) 내부 또는 외부 명령, 실행할 수 있는 프로그램, 또는
배치 파일이 아닙니다. 이란 오류가 나온다

환경변수에 babel-node가 없어 찾지못해 에러가 발생하는거라는데

```javascript
"scripts":{"dev": "nodemon --exec npx babel-node index.js"}
```

로 바꿔주면 실행된다



## #3.1~3.11 server, controlleres, middleware Recap

\# **Server**

> 서버는 인터넷에 연결되어 있으며 24시간 꺼지지 않는 컴퓨터이다.
>
> 서버는 클라이언트(여기서는 브라우저)에서 보낸 request 를 받고 response 보낸다.

\# **Request, Response**

> 클라이언트와 서버는 개방된 포트를 통해 request 와 response 를 주고받는다.
>
> 서버는 request 를 받으면 반드시 response 를 해주어야 한다. 브라우저 무한 로딩이 될 수 있기 때문이다.
>
> HTTP request 는 어떤 route(url) 에 대한 HTTP Method 요청이고 서버는 그 요청에 대한 response 를 해주어야한다. 여기서 중요한 것이 또 **controller**이다.

\# **Controller**

> 컨트롤러는 전달받은 request를 처리하고 response를 전달하기 위한 콜백함수이다. 컨트롤러는 request 와 response 오브젝트를 전달받는다.

\# **Middleware**

> 미들웨어는 컨트롤러가 request 처리 작업을 완료하고 response 를 전달하기 전에 request 처리를 도와주는 콜백함수이다.
>
> 미들웨어는 request 오브젝트와, response 오브젝트 말고도 next 파라미터를 갖는다.
>
> next 파라미터는 다음으로 request 를 처리할 콜백함수를 담고있다.
>
> 1. 미들웨어는 요청과 응답 사이의 소프트웨어.
> 2. 모든 미들웨어는 핸들러, 모든 컨트롤러는 미들웨어다.
> 3. 미들웨어는 next를 포함한 세 개의 argument가 있다. (req, res, enxt)
> 4. next 존재하는 경우 다음 핸들러 함수 next()를 호출.
> 5. middleware에는 next() 가 필수 !!!!
>
> **morgan**
>
> morgan은 node.js용 request logger middleware다.
>
> npm i morgan으로 설치
>
> import morgan form "morgan";
>
> 



## #어딘지 기억안남

middleware는 작업을 다음 함수에게 넘기는 함수, 응답하는 함수 X

mixin 은 partial이긴 한데 데이터를 받을 수 있는 partial

------

href의 앞머리에 / 를 넣으면 어디있든 상관없이 root경로 + /

/를 지우면 현재경로에 / 붙혀서 감

=> 제일앞에 /가있으면 절대경로(videos router에서 실행)
a(href="/video/edit")--->localhost:4000/video/edit
a(href="video/edit")--->localhost:4000/videos/video/edit
a(href=`${video.id}/edit`)--->localhost:4000/videos/1/edit

------

**method는 form과 back end 사이의 정보 전송에 관한 방식**

**get**

> 그 form에 있는 정보가 url에 들어가 검색할 때 필요 검색페이지를 만들 때 사용 그 검색어는 url안에 들어감, 데이터를 오직 받는 목적이라면 get

**post** 

> 데이터베이스에 추가, 수정, 삭제 할 때

------

**app.use(express.urlencoded({extended: true}));**

> express application가 form의 value들을 이해할수 있도록 하고 우리가 쓸 수 있는 자바스크립트 형식으로 변형시켜 준다

> req.body: form의 value값 받기 ex) const {username, password} = req.body

> input에 name넣는걸 까먹으면 req.body에는 데이터가 없다



#4.1 ~ 5.10

코드보는게 편해서 뺌



## #6.8 Connecting to Mongo

Windows 에서 mongo 설치했는데 cmd에서 mongodb커맨드 안될 때

https://dangphongvanthanh.wordpress.com/2017/06/12/add-mongos-bin-folder-to-the-path-environment-variable/





## #6.11 Our First Query

server.js

> server.js는 server의 configuration에 관련된 코드만 처리하기 위해 만들어졌으므로 database나 models같은것은 분리해줘야함



callback

> javascript 에서 기다림을 표현하는 하나의 방법이라 생각



Video.find({}) 

> {}는 serch terms,  이게 비어있으면 모든 형식을 찾는다
>
> logger은 request가 완성되면 출력이 돼야함



return의 역할

> 본질적인 return의 역할보다는 function을 마무리짓는 역할로 사용되고 있음.

> 이러한 경우 return이 없어도 정상적으로 동작하지만 실수를 방지하기 위해 return을 사용render한 것은 다시 render할 수 없음

> redirect(), sendStatus(), end() 등등 포함 (express에서 오류 발생)



## #6.22 Edit Video part Three

```javascript
export const watch = async (req, res) => {
  const { id } = req.params; 
  //const video = await Video.exists({_id:id});
  const video = await Video.findById(id);
  if(video===null){
    return res.render("404", { pageTitle: "Video not found" });
  }

  return res.render("watch", {pageTitle: video.title, video})
};
```

여기에서는 exist를 사용하면 안됨, object를 edit templete으로 보내줘야함

exist는 그냥 존재여부 확인

## #6.23 Middlewares

1. 몽고 사용하기 

> mongo

2. 내가 가진 db 보기 

> show dbs

3. 현재 사용 중인 db 확인 

> db

4. 사용할 db 선택하기 

> use dbName
> (현재 수업에서는 `use wetube`)

5. db 컬렉션 보기 

> show collections

6. db 컬렉션 안에 documents 보기

>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                db.collectionName.find()
>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              (현재 수업에서는 `db.videos.find()`)

7. db 컬렉션 안에 documents 모두 제거하기 

> db.collectionName.remove({})
> (현재 수업에서는 `db.videos.remove({})`)
>
> 

**[몽구스 가이드]** 

**https://mongoosejs.com/docs/guide.html**



**middleware**

> **model이 생성되기 전에 만들어야 함**
>
> ex)
>
> ```javascript
> //middleware
> userSchema.pre("save", async function(){  
> 
> this.password = await bcrypt.hash(this.password,5);
> 
> })
> //model
> const User = mongoose.model("user", userSchema); 
> ```
>
> 

**default export는** 

> ```javascript
> import Video, { formatHashtags } from "../models/Video"
> ```
>
> 라고 치면 Video가 defalut export고 {formatHashtags}가 export



## #6.24 Statics

1. findByIdAndUpdate()에서는 save 훅업이 발생하지 않음 => 다른 방법을 알아보자
2. Video.js에 function을 만들어서 관리하기 => 이것도 괜찮음 근데 다른것도 알아보자
3. static을 사용하면 import 없이도 Model.function()형태로 사용이 가능함 => super cool



## #6.25 Delete

Model.findOneAndDelete()
Model.findOneAndRemove()

> 이 둘은 정말 약간의 차이가 있는데 대부분의 상황에서 타당한 이유가 없는 한 delete를 사용하라고 되어 있음.

> https://www.zerocho.com/category/MongoDB/post/579ecb1fc097d015000404dd
>
> 여기 글을 읽어보니 몽고 db는 롤백이 안되서 remove를 하면 다시 되돌릴 수 없기에 remove보다 delete를 사용하라고 권장하는듯



## #6.26 Search part One

form을 보내면 그 내용은 req.body로 받을 수 있음, => post에서

search 화면에서는 req.query로 받음 => get에서 인듯??



## #6.27 Search part Two

[정규표현식]
https://www.regexpal.com

[몽고DB regex]
https://docs.mongodb.com/manual/reference/operator/query/regex

[RegExp mdn]
https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/RegExp

[정규표현식 참고사이트]

https://wormwlrm.github.io/2020/07/19/Regular-Expressions-Tutorial.html



## #7.2 Creating Account part Three

[비밀번호 털렸다고? 암호화. 해시함수. 5분 설명 영상]
https://www.youtube.com/watch?v=67UwxR3ts2E

[remove() 명령어 실행이 안될 때] 																			db.users.remove()는 deprecated되었기 때문에 ?
db.users.deleteMany({})로 지우기

[해시함수 테스트]
https://emn178.github.io/online-tools/sha256.html

[패키지 설치]
npm i bcrypt



## #7.3 Form Validation

**$or operator: 조건중 하나만 참이어도 값 가져오기**

```javascript
const exists = await User.exists({$or:[{username},{email}]});
```

몽구스 예전버전은 지원 X



## #7.4 Status Codes

[상태코드]
https://ko.wikipedia.org/wiki/HTTP_%EC%83%81%ED%83%9C_%EC%BD%94%EB%93%9C

> \- 200(OK): 서버가 요청을 제대로 처리했다는 뜻이다. 이는 주로 서버가 요청한 페이지를 제공했다는 의미로 쓰인다.
> \- 400(Bad Request): 서버가 요청의 구문을 인식하지 못할 때 발생한다. 클라이언트 측에서 문제가 있을 때 주로 발생한다.
> \- 404(Not Found): 서버가 요청한 페이지를 찾을 수 없을 때 발생한다. 서버에 존재하지 않는 페이지에 대한 요청이 있을 경우 서버는 이 코드를 제공한다.



## #7.6 Login part Two

bcrypt가 생성하는 것을 보면 솔트가 해시의 시작 부분에 있음을 알 수 있다

> ex)$2b$**07**$FxSgL.mY0VlBKg0i7Q/Lp.AUciZE./C2UqtFCU93n7ZC7a0e0ge22
>
> =>07, sort 7번



## #7.7 Sessions and Cookies part One

[세션, 토큰, 쿠키 개념 10분 설명 영상]

https://www.youtube.com/watch?v=tosLBcAX1vk 

쿠키 

> 그냥 옮기는 시스템. 매개체

토큰

> 서버가 기억하는 이상하게 생긴 텍스트 

JWT

> 정보를 갖고있는 토큰, DB 없이 검증가능



1. 브라우져 서버에 접근
2. 서버가 브라우져에게 Cookie 준다.
3. 브라우져가 서버에 다시 접근할 때 2.에서 받은 Cookie를 함께 건냄.
4. 서버는 Cookie를 통해 브라우져를 구분 할 수 있다.

**쿠키를 통해 세션ID 전달 O, 세션data 전달 X**



## #7.8 Sessions and Cookies part Two

**세션은 서버측에서 제공해주는 데이터, 쿠키는 클라이언트측에서 저장하고 사용하는 데이터**

req.sessiontStore() 사용했을 때 한번은 undefined가 나온 이유가 세션은 서버에서 만들어줘야 하는데 클라이언트가 첫 요청때 세션을 가지고있을리 없으니 undefined이 나온거고 그 이후 요청부턴 **첫번째 요청 때 세션을 만들어서 넘겨**줬으니 **클라이언트가 해당 값을 쿠키에 저장**하고 매 요청때마다 서버에게 전달
세션은 서버가 만들어서 제공해주다보니 서버가 재부팅되면 초기화 된다. (그래서 DB에 저장해서 관리를 한다는 소리. 실 운영에선 서버가 꺼지는 일은 없으니깐.)
세션의 값은 서버가 만들어주는 고유값이다보니 해당 값을 기준으로 클라이언트에서 요청한 건에 대해 유저를 특정지을 수 있다



즉, 브라우져에서 서버에 로그인 요청을 해서 로그인이 되면 서버는 세션id를 response해주고
브라우져는 쿠키스토리지에 그 세션id를 보관하고 있다가 이후 다시 서버에 방문할 시에는 그 세션
id만 보여주면 자동으로 로그인되게 해줘서 계속 로그인할 수고를 덜어준다는 것이다



## #7.10 Logged In User part Two

res.locals로 저장된 locals변수는 브라우져에 저장되는게 아니라 서버에 저장되는거



## #7.11 Login Recap

**Cookie, Session**

cookie랑 session은 별개의 개념



**cookie**

> 단지 정보를 주고받는일만 한다
>
> cookie의 장점은 자동적으로 처리되는거 사용자는 아무것도 안해도된다
>
> cookie는 sessionID를 저장하고 서버로 전송시켜 backend에도 sessionID를 저장시킨다

> 브라우저는 우리가 매번 backend localhost에 있는 URL로 request를 보낼 때 마다 cookie가 request랑 같이 전송됨 



**Session store**

> session을 저장하는곳



## #7.12 MongoStore

session id는 쿠키에 저장하지만, session데이터 자체는 서버에 저장

서버에 저장되는 default session storage는 MemoryStore이고, 실제 사용하기 위해 있는건 아님

그래서 session을 데이터베이스에 저장해야함

**[connect-mongo] (세션을 몽고디비에 저장)**

npm i connect-mongo

https://www.npmjs.com/package/connect-mongo



**이미 mongoose 가 mongodb 와 연결되어 있는데 connect-mongo 에 dbURL을 전달해 한번더 연결을 하는 이유가 있나요?**

store: MongoStore.create({ client: connection.client })

위와같이 하면 mongoose 의 client 를 사용해서 세션정보를 저장할 수 있는거같습니다

=> 안해봄



## #7.13 Uninitialized Sessions

**[resave, saveUninitialized 참고자료]**

**https://mongojs.tistory.com/26**

**resave(true,false)** 

> session이 store에서 삭제되면 다시 store에 저장될것이냐 

**saveUninitialized : true** 

>  따로 값을 설정하지 않은 전달 받은 날 것의 세션을 즉시 Store에 저장 후 세션 주인에게 쿠키를 (답장하듯) 넘겨 준다.  --> 말 그대로 값이 초기화(initialize)되지 않아도 저장

**saveUninitialized: false** 

>   req.session 속 값을 수정하는 그 순간에 세션을 Store에 저장 후 그제야 쿠키를 전달한다.(backend가 로그인 한 사용자들에게만 쿠키를 주도록 설정) --> 값이 초기화될때 저장

> =>로그인할때 { req.session.loggedIn = true, req.session.user = user} 





session authentication(인증)을 사용하면서 생길 수 있는 문제점?

## #7.14 Expiration and Secrets

쿠키의 프로퍼티에 대해(Name, Value, Domain, Path, Expires / Max-Age, Size, HttpOnly, Secure, SameSite, Priority)

**Secret**

>  쿠키에 sign 할 때 사용하는 string, 쿠키에 sign하는 이유는 backend가 쿠키를 줬다는걸 보여주기 위함, session hijack(납치, 누군가 쿠키를 훔쳐 마치 본인인거처럼 하는것)라는 공격유형을 방어하기 위함 이 string을 가지고 쿠키를 sign하고 우리가 만든것임을 증명하기위해 쓰임

**Domain**

> 이 쿠키를 만든 backend가 누구인지 알려줌

**Path**

> 그냥 url

**Expires**

> 만료날자를 정하지않으면 값이 session으로 돼있는데 사용자가 닫으면 session 쿠키는 끝나게됨, 예를들어 몇몇브라우저에서 프로그램을 닫거나 컴퓨터를 재시작 할 때 이 쿠키는 사라지는거다 (이해가 잘 안됨)

**Max-Age**

> 언제 session이 만료되는지 정하는거에 쓰인다

```javascript
app.use(session({
    secret:"Hello",
    resave:true,
    saveUninitialized: true,
    cookie: {
        maxAge: 20000, // => 20초 뒤에 만료
    },
    store: MongoStore.create({mongoUrl:"mongodb://127.0.0.1:27017/wetube"})
}))

```



## #7.15 Environment Variables

**env파일**

> 모든 API key나 모든 비밀로 해야하는 url을 넣는곳

**evn파일에 접근하는법**

> process.env.variableName

**dotenv**

> env파일을 읽고 각각의 변수들을 process.env안에 넣어준다\



dotenv는 가장 위에 import를 해줘야함, env를 로드하기위해 

import 대신 require("dotenv").config();로 받아오려면 dotenv를 사용하려는 모든 파일의 첫번째에 해줘야한다 너무 비효율적이므로 가장 처음으로 실행되는 파일에 import하자

**npm i dotenv**

https://www.npmjs.com/package/dotenv

import dotenv from "dotenv", dotenv.config() 대신
import "dotenv/config"로 바로 dotenv config함수를 불러와서 실행 가능



## #7.16 ~ 7.21 Github Login

깃허브 OAuth Apps
https://github.com/settings/developers

깃허브 OAuth Apps 공식문서
https://docs.github.com/en/developers/apps/building-oauth-apps/authorizing-oauth-apps



깃허브로그인 절차

**#1 사용자를 깃허브로 보내기, 우리에게 정보를 공유하는 것을 승인(로그인)**
**#2 깃헙은 사용자를 token과 함께 우리 웹사이트로 redirect 시킴**
**#3 우리는 그 token으로 사용자의 정보를 받아옴 token이 빠르게 만료**



**#1 사용자를 깃허브로 보내기, 우리에게 정보를 공유하는 것을 승인(로그인)**

**GET https://github.com/login/oauth/authorize** 

Parmeters

> client_id: 등록할 때 github에서 받은 클라이언트 ID (required)
>
> redirect_uri string: 승인 후 사용자가 전송될 애플리케이션의 URL
>
> allow_signup(true, false): 인증되지 않은 사용자에게 회원가입 옵션 제공
>
> login: 로그인하고 인증하는데 사용할 특정 계정을 제안(?)
>
> state: .사이트 요청 간 공격으로부터 보호(?)
>
> scope: 유저에게서 얼마나 많이 정보를 읽어내고 어떤 정보를 가져올 것인지
>
> > **read:user** 프로필정보, 만약 read:user를 요청하지 않는다면 user의 정보를 읽을 수 있는 access_token을 받을 수 없다.
> >
> > user:email 이메일주소
> >
> > delete_repo 어떤 repository든 삭제할 수 있다(?)
> >
> > 등등 https://docs.github.com/en/developers/apps/building-oauth-apps/scopes-for-oauth-apps



github 로그인 창

```javascript
//login.pug
a(href="/users/github/start") Continue with GitHub &rarr;

//userRouter
userRouter.get("/github/start", startGithubLogin);

//githubLogin controller
//#1
export const startGithubLogin = (req, res) =>{
  const baseUrl = "http://github.com/login/oauth/authorize";
  const config = {
    client_id: process.env.GH_CLIENT,
    allow_signup: false,
    scope: "read:user user:email"
  }
  const params = new URLSearchParams(config).toString();
  const finalUrl = `${baseUrl}?${params}`
  return res.redirect(finalUrl);
};
```

=> login.pug에서 controller로 이동 후 github authorize로 redirect

![githubLogin1](https://user-images.githubusercontent.com/48901587/143609971-60950d6a-7d9d-4425-ba51-63d094231b4d.PNG)



**#2 깃헙은 사용자를 token과 함께 우리 웹사이트로 redirect 시킴**

github에서 받은 토큰을 Access토큰으로 바꿔줘야한다.

parameter들과 함께 POST 요청을 해야함 (fetch)

**POST https://github.com/login/oauth/access_token**

Parmeters

> client_id: 등록할 때 github에서 받은 클라이언트 ID (required)
>
> client_secret: 오로지 백엔드에만 존재해야되는 secret, 절대 아무한테도 보여주면 안됨 (required)
>
> code: **#1**에 대한 response로 받은 코드(어느정도 시간이 지나면 만료)



alert가 브라우저에만 존재하고node.js에서 안되는것처럼 fetch도 node.js에 존재하지 않는데 사람들이 node-fetch라는 패키지를 만들었다

node-fetch가 version3을 내면서 이 강의에서 하는 버전과 맞지않아 2.6.1버전을 받아야한다

[패키지 설치]
npm i node-fetch@2.61



```javascript
//githubLogin controller
//#2
export const finishGithubLogin = async (req, res) => {
  const baseUrl = "https://github.com/login/oauth/access_token"
  const config = {
    client_id: process.env.GH_CLIENT,
    client_secret: process.env.GH_SECRET,
    code : req.query.code
  }
 const params = new URLSearchParams(config).toString();
 const finalUrl = `${baseUrl}?${params}`
 const tokenRequest = await (
   await fetch(finalUrl,{
   method: "POST",
   headers:{
    Accept: "application/json",
   },
 })
 ).json();
//fetch를 요쳥하고 fetch가 돌아오면 해당 fetch의 JSON을 받는다
 
```

res.send(JSON.stringify(json)), json으로 토큰을 받아왔다

> ![githubLogin2](https://user-images.githubusercontent.com/48901587/143609986-8c3a4fea-a7d7-4632-b98f-ea87d9980a5b.PNG)



**#3 우리는 그 token으로 사용자의 정보를 받아옴, token이 빠르게 만료**

access_token을 갖고 API에 접근하기, 이제 access_token을 가지고 user의 정보를 얻을 수 있다

```javascript
//githubLogin controller
//#2
export const finishGithubLogin = async (req, res) => {
  const baseUrl = "https://github.com/login/oauth/access_token"
  const config = {
    client_id: process.env.GH_CLIENT,
    client_secret: process.env.GH_SECRET,
    code : req.query.code
  }
 const params = new URLSearchParams(config).toString();
 const finalUrl = `${baseUrl}?${params}`
 const tokenRequest = await (
   await fetch(finalUrl,{
   method: "POST",
   headers:{
    Accept: "application/json",
   },
 })
 ).json();
//#3
 if("access_token" in tokenRequest){//토큰이 있을때
   const {access_token} = tokenRequest;
   //const access_token = json.access_token;
   const userData = await (
       await fetch("https://api.github.com/user",{
    headers: {
      Authorization: `token ${access_token}`//토큰 전달
    }
   })
   ).json();
 console.log(userData);//유저정보 console
 }else{
   return res.redirect("/login")
 }
}
//fetch를 요쳥하고 fetch가 돌아오면 해당 fetch의 JSON을 받는다
```

**유저정보 console**

![githubLogin3](https://user-images.githubusercontent.com/48901587/143609992-5bc27053-f418-4a5e-88c2-c928fffcbf86.PNG)

**access_token**

> **access_token은 user가 모든걸 할 수 있게 해주진 않는다 config의 scope에 명시를 해줘야 github가 code를 주고(req.query.code) 그 코드에는 이미 하고자 하는바가 명시돼있다 그래서 그 코드를 access_token으로 바꾸게되면 access_token은 이미 명시돼있는 일만 하게된다**



**#4 email**

근데 위의 코드들은 scope에서 user:email은 읽어들이지 않고있다

> 위의 console창의 email:null은 기본적으로 read:user로 정보를 가져올 때 email이 private인거, user:email과는 별개

그냥 fetch를 한번 더 사용하면 된다



[user:email scope참고자료]

https://docs.github.com/en/rest/reference/users#emails

> **List email addresses for the authenticated user**
>
> Lists all of your email addresses, and specifies which one is visible to the public. This endpoint is accessible with the `user:email` scope.
>
> ```
> GET /user/emails
> ```
>
> [Parameters](https://docs.github.com/en/rest/reference/users#list-email-addresses-for-the-authenticated-user--parameters)
>
> | Name       | Type    | In     | Description                                                 |
> | :--------- | :------ | :----- | :---------------------------------------------------------- |
> | `accept`   | string  | header | Setting to `application/vnd.github.v3+json` is recommended. |
> | `per_page` | integer | query  | Results per page (max 100)Default: `30`                     |
> | `page`     | integer | query  | Page number of the results to fetch.Default: `1`            |



```javascript
//#4
   const emailData = await(
     await fetch(`${apiUrl}/user/emails`, {
       headers: {
        Authorization: `token ${access_token}`
       }
     })
   ).json();
   console.log(emailData);
```

**email정보 console**

![githubLogin4](https://user-images.githubusercontent.com/48901587/143609998-306f8277-caed-4d3c-b5ce-448a7b38deb2.PNG)

**#5 email이 verified이면서 primary인 것들을 찾아야한다**

> 이유: 가끔 github으로 계정을 생성해도 primary 혹은 verified가 안되었을 수도 있어서

```javascript
//#5
const emailObj = emailData.find(email => email.primary === true && email.verified ===true)
```



**#6 해당 email을 가진 유저가 이미 있는지 확인 후 있다면 로그인, 없다면 회원가입 후 로그인**

```javascript
//#5
const emailObj = emailData.find(
      (email) => email.primary === true && email.verified === true
    );
    if (!emailObj) {
      return res.redirect("/login");
    }
//#6
    let user = await User.findOne({ email: emailObj.email });
    //console.log("existingUser", existingUser);
    // 해당 이메일을 가진 user가 이미 있는지
    if (!user) {//회원가입
      user = await User.create({
        name: userData.name ? userData.name : "Unknown",
        //github 프로필 설정 안하면 name이 없어서 name path를 찾을 수 없다고 에러나서 예외처리
        username: userData.login,//이게 일반로그인 유저의 username과 겹칠경우도 나중에 고려해야할듯
        email: emailObj.email,
        password: "",
        socialOnly: true,
        location: userData.location,
      } );//로그인
      req.session.loggedIn = true;
      req.session.user = existingUser;
      return res.redirect("/");
    }
```



**#7 logout**

그냥 session을 없애고 홈화면으로 리다이렉트 하면 된다

```javascript
//#7
export const logout = (req, res) => {
  req.session.destroy();
  return res.redirect("/");
}
```





전에 프로젝트 할때 서버랑 데이터 통신하는 fetch사용을 이런 방식으로 then안에서 변수, 함수접근하고 then 안에서 fetch를 한번 더 사용했었다 확실히 아래 코드보다 위의 코드들이 훨신 깨끗하고 알아보기 쉬운거같다

```javascript
//#2, #3
fetch(finalUrl, {
  method: "POST",
  headers: {
    Accept: "application/json",
  },
})
.then((response)=> response.json())
.then((json) => {
  if("access_token" in json) {
    const{ access_token } = tokenRequest;
    const apiUrl = "https://api.github.com";
    fetch(`${apiUrl}/user`, {
      headers: {
        Authorization: `token ${access_token}`,
      },
    })
    .then((response) => response.json())
    .then((josn)=> {
      fetch(`${apiUrl}/user/emails`,{
        headers: {
          Authorization: `token ${access_token}`
        },
      });
    });
  }
});
```



## #8.6 ~ 8.9 File Uploads

multer: 파일을 업로드 할 수 있게 도와주는 middleware
[패키지 설치] 
npm i multer
[참고자료]
https://www.npmjs.com/package/multer

multer는 multipart가 아닌 form을 처리하지 않아서 form에
enctype = "multipart/form-data" 로 encoding type을 multipart/form-data로 바꿔줘야 한다

> form(method="POST", enctype = "multipart/form-data")

**multer기능**

> 1. form으로 보낸 파일 업로드
> 2. 파일명 랜덤생성(같은 이름의 파일을 업로드 해도 문제X)
> 3. 파일을 지정한 폴더에 저장
> 4. 다음 순서의 controller에 파일에 관한 정보 제공



```javascript
#1 middleware
export const avatarUpload = multer({
    dest: "uploads/avatars/", //저장 할 폴더
    limits: {
        fileSize: 3000000,//파일용량제한 3MB
    }
});
#2 view
form(method="POST", enctype = "multipart/form-data")
	label(for="avatar") Avatar 
	input(type="file", id = "avatar", name="avatar", accept="image/*")
#3 userRouter
userRouter
  .route("/edit")
  .all(protectorMiddleware)
  .get(getEdit)
  .post(avatarUpload.single("avatar"), postEdit);
//single: 하나의파일을 업로드, "avatar" input name
```

multer는 input으로 파일을 받아서 그 파일을 uploads 폴더에 저장한 후 그 파일 정보를 postEdit에 전달(req.file)

**참고 : DB에는 파일을 절때 보관하지 않는다(파일의 위치만 저장)**

> 데이터베이스는 엑셀 시트 같은 것이라고 니꼬쌤이 어디선가 설명했었는데, 시트에서도 그렇고, 이번 영상에서도 콘솔상으로도 데이터베이스 출력을 했을 때 이미지는 표시할 수가 없다. 일반적으로는 이미지든 영상이든 뭐든지 다 쌓아놓는곳, 창고 같은 곳 = 데이터베이스라는 인식이 있는데 엄밀하게 말하면 뭐든지 다 쌓아놓는 곳은 하드, 혹은 웹하드, AWS에서는 S3에 해당하는 것이고 데이터베이스는 문자, 테이블, 시트로 표현할 수 있는 것이라고 한다.
>
> 따라서 데이터베이스 자체에는 이미지를 저장할 수 없기 때문에 경로만 저장해두며 해당 경로에 있는 이미지를 별도로 찾게 되는 것이다.
>
> 파일원본은 Amazon의 하드드라이브 같은데 저장하면 된다



**static files serving(폴더 전체를 브라우저에게 노출시킨다)**
[참고자료]
https://expressjs.com/ko/starter/static-files.html

> 브라우저가 서버에 있는 파일에 접근할 수 없으니깐 우리가 브라우저한테 어디로 가야하는지 알려줘야한다 브라우저가 서버의 어떤 폴더로든 갈 수 있다고 생각하면 보안상 좋지않음, 그래서 우리가 브라우저가 어떤 페이지와 폴더를 볼 수 있는지 알려줘야함



```javascript
app.use("/uploads", express.static("uploads"));
```

> express에게 만약 누군가 /upload로 가려고한다면, uploads폴더의 내용을 보여줘라



upload폴더에 사진이 전에 올린 사진들까지 여러가지 저장돼있는 방식의 문제점

> 1. 우리가 파일을 서버에 저장한다는것: 서버는 계속 종료되고 다시 시작하는걸 반복하므로 좋은방법이 아님 뭔가를 업데이트 하면 새로운 서버를 만들어 다시 시작하므로 그 전 서버에 저장돼 있던 파일들은 날아간다
> 2. 서버가 죽었을 때 코드와 업로드된 파일들이 있다면, 파일은 날아간다
>
> 해결방법: 파일을 우리 서버에 저장하는게 아니라 다른곳에 저장하는거로 바꿔 서버가 사라졌다 다시 돌아와도 파일은 그대로 있도록 바꿔야한다 
>
> => 실제 서버에 배포할때 한다고함



## #8.11 ~ 8.13 relationship between user and video

video와 user를 연결해야한다 DB의 id를 가지고 둘을 연결해본다

user에는 해당 user가 업로드한 모든 영상의 id를 저장, video에는 해당 video를 만든 owner 저장

**video에 owner저장**

```javascript
//VideoSchema
owner: { type:mongoose.Schema.Types.ObjectId, required: true, ref:"User"}
//UserModel
const User = mongoose.model("User", userSchema);//"User"이 ref와 연결
//다른 schema의 타입들은 js에서 지원하는건데 ObjectId는 mongoose의 스키마타입, ref는 ObjectId가 model user에서 온다고 알려주는거
```

이제 video를 업로드 할 때 owner에 _id를 추가해주면된다.

**populate**

> ref(reference):"User" 가 videoSchema와 userSchema를 연결해줘 한번에 비디오와 그 비디오의 owner를 찾을 수 있다.
>
> ```javascript
> //populate 사용
> //videoController
> const video = await Video.findById(id).populate("owner");
> //populate("schema의 속성이름")
> 
> //populate하기 전 video의 owner
> owner: new ObjectId("61a773af49cb2c1e6dea986a"),
> //populate후 video의 owner
> owner: {
> _id: new ObjectId("61a773af49cb2c1e6dea986a"),
> email: 'rladbrua0207@gmail.com',
> avatarUrl: 'https://avatars.githubusercontent.com/u/48901587?v=4',
> socialOnly: true,
> username: 'rladbrua0207',
> password: '$2b$05$TBMhdTVXJ1l5b19Y6AiC..ahdiOrmOi5kgNb2aUlP8JB1ztjJ.kce',
> name: 'Unknown',
> location: null,
> __v: 0
> },
> ```
>
> populate를 사용 안하면
>
> ```javascript
> //video에 저장돼있는 owner의 id를 통해 다시 DB에 접근을 해 user정보를 가져와야한다
> const owner = await User.findById(video.owner);
> ```





**user에  본인video저장**

> user의 videos속성에 새로운 videoId 저장

```javascript
//UserSchema
videos: [{type: mongoose.Types.ObjectId, ref: "Video"}]
//videos는 Video model에 연결된 ObjectId로 구성된 array

//videoContorller create video 
const user = await User.findById(_id);// _id: userId
user.videos.push(newVideo._id); //생성된 비디오의 id를 usermodel에 저장
user.save(); 
//user.save()를 할 경우 userModel에서 password가 두번 hash됨 이 문제는#8.14에서 다룸
```

> video는 여러 owner를 가질 수 있는데 owner는 여러 video를 가질 수 없으므로 type:array

**populate**

> populate를 어디에 스고 안 쓸지를 잘 생각해봐야함 필요없는 데이터를 굳이 populate를 써서 로드할 필요는 없음 안써도 된다면 안쓰고 해결

```javascript
//populate 사용
//userController
const user = await User.findById(id).populate("videos");
//populate("schema의 속성이름")
//populate하기 전 user의 videos
videos: [ new ObjectId("61a796974b50374ed2701092") ]
//populate후 user의 videos
videos: [
    {
      meta: [Object],
      _id: new ObjectId("61a796974b50374ed2701092"),
      title: 'bunny',
      fileUrl: 'uploads\\videos\\78da92bba8a27f0aab86a67bc5acb7de',
      description: '123451234512345123451234512345',
      hashtags: [Array],
      owner: new ObjectId("61a7966e4b50374ed270108f"),
      createdAt: 2021-12-01T15:36:55.995Z,
      __v: 0
    }
  ],
```





## #8.14 Bugfix

**password가 user.save() 할 때마다 hash 되는 문제**

```javascript
//password가 수정됐을 경우에만 hash되게
userSchema.pre("save", async function () {
  if (this.isModified("password")) {//isModified: 수정이됐을경우 true
    this.password = await bcrypt.hash(this.password, 5);
  }
});
```



**video edit form이 모든사람에게 나타나는 문제**

```javascript
//영상의 주인이 아니면 이 페이지에 접속 못하게
export const getEdit = async (req, res) => {
  const {
    params:{ id },
    session:{user: {_id}}
  } =req;
  const video = await Video.findById(id);
  if(!video){
    res.status(404).render("404", { pageTitle: "Video not found" });
  }
  if(String(video.owner) !== String(_id)){//요기
    return res.status(403).redirect("/");
  }
  res.render("edit", { pageTitle: `Edit ${video.title}`, video});
};
//postEdit, deleteVideo에도 같은방법 적용
```



**deleteVideo 에서 Video db는 지워졌지만, User db에 videos가 남아있는 문제 (강의X)**

```javascript
//splice로 삭제
export const deleteVideo = async (req, res) => {
const { id } = req.params;
const {
user: { _id },
} = req.session;
const video = await Video.findById(id);
const user = await User.findById(_id);
if(!video){
return res.status(404).render("404", { pageTitle: "Video not found." });
}
if (String(video.owner) !== String(_id)) {
return res.status(403).redirect("/");
}

await Video.findByIdAndDelete(id);
user.videos.splice(user.videos.indexOf(id),1);//요기
user.save();
return res.redirect("/");
}
//splice참고 https://im-developer.tistory.com/103
```





## #9.0 ~ 9.7 Webpack



Webpack은 .jpg 같은 거는 압축된 jpg 를 주고, JS 는 오래된 버전의 JS로, Sass 는 못생긴 css 로 준다. 압축, 변형, 최소화등 필요한 작업들을 거치고 정리된 코드를 결과물로 준다.

[웹팩의 기본 개념 참고]
https://jeonghwan-kim.github.io/js/2017/05/15/webpack.html

[webpack, webpack-cli을 devDependencies 로 설치]
npm i webpack webpack-cli -D

Webpack 시작하기: https://webpack.kr/guides/getting-started/
Webpack 설정: https://webpack.kr/concepts/configuration/

Webpack CLI를 이용해서 콘솔에서 Webpack을 불러낼 수 있다.

webpack.config.js 

> 이 파일에서 webpack 환경설정. 
>
> Webpack이 읽을 configuration 파일을 내보낸다
>
> 이 파일에서는 오래된 javascript 코드만 이해할 수 있다.

중요한 거 두 가지(필수 설정)

> \- entry: 우리가 처리하고자 하는 파일들(예쁜 js)
> \- entry: 이 프로퍼티에 우리가 처리하고자 하는 파일의 경로 입력
> \- output: 결과물
> \- filename: 이 프로퍼티에 우리 결과물이 될 파일 이름 입력
> \- path: 이 프로퍼티에 우리 결과물 파일을 어디에 저장할 지 지정 (이 경로는 절대경로여야 해!)



**__dirname(directory name)**

> 말 그대로 파일까지의 경로 전체 자바스크립트가 제공하는 상수

**path.resolve()**

> 몇 개가 됐든 입력하는 파트들을 모아서 경로로 만들어주는 메서드
>
> ```javascript
> const path = require("path");
> console.log(path.resolve(__dirname, "assets", "js"));
> // => 현재경로/assets/js
> ```

**rules**

> 각각의 파일 종류에 따라 어떤 전환을 할 건지 결정



**babel-loader**

> [babel-loader 설치]
> npm install babel-loader -D
> https://github.com/babel/babel-loader
>
> webpack loader
> https://webpack.kr/loaders/
>
> webpack babel-loader
> https://webpack.kr/loaders/babel-loader/

[main.js에 빈 파일 나오는 오류]

> mode를 설정해주지 않으면 기본적으로 production으로 설정되어 client/js폴더 내에 작성한 main.js를 변환했을 때, 빈 파일로 나올 수 있다
> 빈 파일 나오면 module.export안에 mode: "development"로 설정



**client폴더는 코딩할 폴더(webpack이 처리하기 전), assets폴더는 브라우저가 접근해서 볼 폴더(webpack이 실행되고 난 다음 만들어진 파일)**



**server.js에서 express한테 사람들이 asset폴더를 볼 수 있게 요청을해야함(uploads폴더 랑 같음)**

```javascript
app.use("/assets", express.static("assets"));
// =>app.use("/url이름", express.static("assets"));
//url이름을 폴더명과 다르게 바꿔도 된다
```



**scss**

> scss는 loader가 3개 필요함, webpack의 순서
>
> 1. scss를 일반 css로 변형할 loader
> 2. 폰트불러올때 css에 쓰일 loader
> 3. 변환한 css를 웹사이트에 적용시킬 loader
>
> ```javascript
> use: ["style-loader", "css-loader", "sass-loader"]
> //제일 마지막에 있는 loader가 webpack이 제일 먼저 사용할 loader
> ```
>
> [sass, sass-loader, css-loader, style-loader 설치]
>
> npm i sass sass-loader css-loader style-loader -D
>
> [참고자료]
> https://github.com/webpack-contrib/sass-loader
> https://www.npmjs.com/package/css-loader
> https://webpack.js.org/loaders/style-loader/#root



**css파일 분리하기**

> MiniCssExtractPlugin
> npm install --save-dev mini-css-extract-plugin
> https://webpack.kr/plugins/mini-css-extract-plugin/
>
> CssMinimizerWebpackPlugin
> https://webpack.kr/plugins/css-minimizer-webpack-plugin/
>
> ```javascript
> //import
> const MiniCssExtractPlugin = require("mini-css-extract-plugin");
> //module.exports
> plugins: [new MiniCssExtractPlugin()],
> //rules
> use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
> ```
>
> 



**watch: true**

자동으로 webpack에서 js, css가 변경되는지 확인 후 적용



프론트의js가 변경될때 백에서도 재시작되는거 막으려면
=> nodemon에게 몇가지 파일이나 폴더들을 무시하는 방법을 알려줘야함

> nodemon.json파일을 만든 후
>
> ```javascript
> //nodemon.json
> {
>  "ignore": ["webpack.config.js", "src/client/*", "assets/*"],
>  "exec": "npx babel-node src/init.js"
> }
> //package.json
> "scripts": {
>      "dev": "nodemon",  
>      "assets": "webpack --config webpack.config.js"
>  },
> //dev를 nodemon으로 짧게 바꿈
> ```



## #10 styles

header, footer, 등 partials, mixin: components폴더에 componets파일 만들기

home, search, join, login 같은 template: (URL같은거) screen폴더에 screen파일 만들기



## #12 Views API

템플릿을 랜더링하지 않는 views : api views, 대부분의 인터넷이 이렇게 작동
요즘은 거의 CSR사용

API는 프론트엔드와 백엔드가 서버를 통해 통신하는 방법을 말함

```javascript
//client/js/videoPlayer
const handleEnded = () =>{
  const {id} = videoContainer.dataset;
  fetch(`/api/videos/${id}/view`, {
    method: "POST",
  });
//비디오가 끝났을 때 POST요청
};
video.addEventListener("ended", handleEnded);

//server
import apiRouter from "./routers/apiRouter";
app.use("/api", apiRouter);
//apiRouter
import express from "express";
import { registerView } from "../controllers/videoController";

const apiRouter = express.Router();
apiRouter.post("/videos/:id([a-f0-9]{24})/view", registerView);

export default apiRouter;


//videoController
export const registerView = async (req, res) => {
  const {id} = req.params;
  const video = await Video.findById(id);
  if(!video){
    return res.sendStatus(404);
  }
  video.meta.views = video.meta.views +1; //조회수 +1
  await video.save();
  return res.sendStatus(200);
}//return res.status로하면 의미 X(pending상태)
```



**[dataset]**

https://developer.mozilla.org/ko/docs/Learn/HTML/Howto/Use_data_attributes

HTML문법

> ```html
> <article
> id="electriccars"
> data-columns="3"
> data-index-number="12314"
> data-parent="cars">
> ...
> </article>
> ```

JavaScript에서 접근

> ```javascript
> var article = document.getElementById('electriccars');
> article.dataset.columns // "3"
> article.dataset.indexNumber // "12314"
> article.dataset.parent // "cars"
> ```



**상태코드**

```javascript
//상태코드를 리턴해줄 때 render같은것을 써줘야 의미가 있다
return res.status(404);//의미X(pending)
return.res.sendStatus(404)
```



## #13 Video Recoder

[MediaDevices.getUserMedia()]

https://developer.mozilla.org/ko/docs/Web/API/MediaDevices/getUserMedia



프론트에서 async, await를 사용하려면 regeneratorRuntime를 설치해야한다

[regeneratorRuntime설치]

npm i regenerator-runtime



```javascript
const startBtn = document.getElementById("startBtn");
const video = document.getElementById("preview");
let stream;
let recorder; 
let videoFile;
const handleDownload = () =>{
    const a = document.createElement("a");
    a.href = videoFile;
    a.download = "MyRecording.webm";
    document.body.appendChild(a);//body에 존재하지 않는 링크는 클릭 할 수 없기때문에 추가
    a.click();
}
const handleStop = () =>{
    startBtn.innerText= "Download Recording";
    startBtn.removeEventListener("click", handleStop);
    startBtn.addEventListener("click", handleDownload);
    recorder.stop();
}
const handleStart = () => {
    startBtn.innerText = "Stop Recording";
    startBtn.removeEventListener("click", handleStart);
    startBtn.addEventListener("click", handleStop);
    recorder = new MediaRecorder(stream);
    recorder.ondataavailable = (e) => {
        videoFile = URL.createObjectURL(e.data);//브라우저가 파일에 접근할 수 있는 URL
        video.srcObject = null; //비디오의 미리보기 제거(?)
        video.src = videoFile;
        video.loop = true; //반복재생
        /*
        왜 video.srcObject로 안하나 했는데 MDN에서 지금 한 방법은 옛날방법이라고 한다.
        
        ex) 옛날방식
        const mediastream = await navigator.mediaDevices.getUserMedia({video: true});
        const video = document.createElement("video");
        video.srcObject = mediaStream;
        요즘방식
        const mediaSource = new MediaSource();
        const video = document.createElement("video");
        video.srcObject = mediaSource
        */
        video.play();
    }
    recorder.start();
};
const init = async() =>{
    stream = await navigator.mediaDevices.getUserMedia({
        audio: false,
        video: true,
    })
    video.srcObject = stream; //video 태그
    video.play();
}
init();
```



ondataavailable

> 녹화가 멈추면 발생되는 이벤트
>
> ondataavailable 이벤트 핸들러의 인자로 전달되는 event 객체에는 data 속성이 있으며, source에서 생성되는 Blob 형의 데이터를 참조하고 있다



createObjectURL

> 브라우저 메모리에서만 가능한 URL 만들어줌



## #14 WebAssembly Video Transcode

(이챕터는 나중에 따로 들을거)

**웹어셈블리 참고영상**

https://www.youtube.com/watch?v=KjgDxBLv0bM

폴더와 파일이 있는 가상의 컴퓨터를 브라우저에서 실행

**FFmpeg**

> 비디오를 압축하거나 비디오 포맷을 변환하거나 비디오에서 오디오 추출, 비디오에서 스크린샷, 비디오를 여러가지 포맷과 화질로 인코드 등등 여러가지 할 수 있음
>
> 무겁고, 보통은 백엔드에서 사용하지만 webassembly덕분에 프론트엔드에서도 사용 가능

**WebAssembly**

> 웹사이트가 매우 빠른 코드를 실행할 수 있게 해줌(Javascript를 사용하지 않고, 다른 종류의 프로그램 사용)

사용자의 브라우져에서 비디오 변환

FFmpeg와 WebAssembly를 결합한 ffmpeg.wasm을 사용

**ffmpeg.wasm**

> 비디오를 변환하기 위해 사용자의 컴퓨터 사용(서버에서 변환하는건 돈들음)



패키지 다운로드
npm i @ffmpeg/ffmpeg @ffmpeg/core

버전 에러때문에

npm install @ffmpeg/core@latest 설치하고
recorder.js 에
const ffpmeg = createFFmpeg({
corePath: 'https://unpkg.com/@ffmpeg/core@0.10.0/dist/ffmpeg-core.js',
log:true
});
로 수정

참고사이트
https://www.npmjs.com/package/@ffmpeg/ffmpeg



또 버전에러를 해결하니깐 이번엔 영상을 다운로드할 때 
Uncaught (in promise) ReferenceError: SharedArrayBuffer is not defined 라는 에러가 뜬다 이거를

```javascript
//server 
app.use((req, res, next) => {
res.header("Cross-Origin-Embedder-Policy", "require-corp");
res.header("Cross-Origin-Opener-Policy", "same-origin");
next();
});
```

ffmpeg 사용 당시 부딪힌 sharedArrayBuffer 에러를 해결하러면 이 header를 설정해줘야 한다 근데 여기서 배포할때 보면 비디오랑 프로필사진 로드가 안된다 이건 #17에서 확인



## #15 Falsh Messages

express-flash

> 템플릿에다 사용자에게 메시지를 남길 수 있게 해주는 미들웨어, 이 메세지는 session에 있어 한 사용자만이 볼 수 있다
>
> [패키지설치]
>
> npm i express-flash
>
> ```javascript
> //이 패키지를 설치하므로 req.flash()를 사용할 수 있고, messages locals를 만들어줘 view에서 사용할 수 있다.
> //server
> import flash from "express-flash";
> app.use(flash());
> //ex) 로그인안한 사용자 막는 middleware
> export const protectorMiddleware = (req, res, next) => {
>  if(req.session.loggedIn){
>      return next();
>  }else{
>      req.flash("error", "Not authorized");// 타입, 메세지
>      return res.redirect("/login");
>  }
> };
> //메시지가 한번 view에서 보여지면 express가 메시지를 cache에서 지워서 한번만 보여질 수 있다.
> ```
>
> 



## #16 Comment Section

**express.json()**

> express의 string을 받아서 json으로 바꿔주는 middleware

```javascript
//server
app.use(express.json());

//videoController.js
return res.Status(201).json({newCommentId: comment._id});//response로 commentId 보내는법

//commentSection.js
//header은 기본적으로 request에 대한 정보를 담고있다.
    const response = await fetch(`/api/video/${videoId}/comment`,{
    //{status} = ~~~
        method:"POST",
        headers:{
            "Content-Type" : "application/json",
        },
        body: JSON.stringify({
            text,
        }),
    });
    textArea.value = "";
    const json = await response.json();//
    if(response.status === 201){
        addComment(text);
    }
```

1. fetch로 백엔드에 요청을 보낼 때에
   method: "POST",
   headers: {},
   body: {},

   URL과 더불어 이 세 가지를 덧붙여야 한다.

2. headers에는 이 요청의 세부 사항을 명시하며, body에는 실질적인 컨텐츠가 포함된다.

3. 따로 명시하지 않을 시에 모든 body의 컨텐츠는 Text File로서 전송되고 받아 인식된다.

4. 특히 body: { ... }, 이런 식으로 자바스크립트 오브젝트를 넘겨줄 시 외부에서 이 오브젝트는 [object Object]라는 의미 없는 문자열로 변환된다.

5. 오브젝트와 그 안의 세부 변수 목록들을 넘겨주고 싶을 시, JSON이라는 규약에 의거한 오브젝트 내의 모든 기록을 텍스트화하여 넘겨주어야 하는데, 이때 JSON.stringify({ ... }) 라는 편리한 자체 표준 함수를 사용하면 된다.

6. 덧붙여 headers 안에 "Content-Type": "application/json"이라는 명시를 해 주어 전송된 텍스트가 JSON파일임을 백엔드에 인식시켜 준다.

7. 백엔드에 (이를테면 express를 사용 중이라면) app.use(express.json()); 미들웨어를 추가해주어 자체 내에서 JSON.parse("..."); JSON파일을 다시 자바스크립트 오브젝트로 변환해주는 표준 함수로 요청 body 내의 컨텐츠를 디코딩하는 작업을 한다.

8. fetch를 할 경우 여느 때와 똑같이 브라우저는 쿠키를 함께 전송한다.



## #17 DEPLOYMENT

**Heroku를 통해 배포**

어떤 node.js 환경에서도 서버가 실행될 수 있게 설정을 바꿔야함

> DB, Amazon Web Services, 코드를 production방법으로 빌드, 코드압축 등등 해야함



babel-node는 실제로 서비스 되는 곳이 아니라 개발할 때만 사용되는 목적으로쓰임 바벨노드는 ES6이상에서 사용되는 자바스크립트 코드를 실행할 수 있게 도와주지만 성능문제가 있음(bavel-node는 느림)

그래서 init.js를 일반적인 javascript 코드로 바꿔야함
=> Babel CLI

Babel CLI

> https://babeljs.io/docs/en/babel-cli
> npm install --save-dev @babel/core @babel/cli

```javascript
//package.json
"scripts": {
        "build:server" : "babel src -d build",
//src를 bulid, -d 로 특정directory 지정(build)
    },
//server
app.set("views", process.cwd() + "/src/views");
```

babel이 src 폴더를 빌드하고 결과물을 build 폴더에 저장,

build를 해도 views 파일은 안넘어감 근데 server에 view를 설정하는 부분에서 process.cwd()가 package.json을 갖고있는 root폴더를 가리킴 그래서 굳이 view가 안넘어가져도 랜더링이 잘됨

그래서 빌드서버는 환경변수(env)에 접근할 수 있다



**webpack의 두가지모드**

development, production

webpack.config.js의 mode: "development", watch:true 를 적지않고 webpack을 실행할 때 적용

development

> ```javascript
> //package.json
> "dev:assets": "webpack --mode=development -w"
> //-w : watch:true => client파일 변경될때마다 webpack이 assets파일로 번역
> ```

production

> ```javascript
> //package.json
> "build:assets": "webpack --mode=production"
> ```
>
> 그냥 assets파일이 다 한줄로 바뀜



**heroku Git으로 배포**

Heroku CLI 설치

> https://devcenter.heroku.com/articles/heroku-cli

heroku login을 치면 

heroku: Press any key to open up the browser to login or q to exit: 라는게 나와야하는데 cmd에서만 나오고 powershell에서는 안나와서 알아보다가 powershell에서 Set-ExecutionPolicy RemoteSigned해주니깐 됐다

> 참고사이트:https://cloudsns.wordpress.com/2012/07/04/set-executionpolicy%EC%9D%98-remotesigned%EC%9D%98-%EC%9D%98%EB%AF%B8/

heroku는 오직 git history만 봄 commit 필수

**heroku logs --tail**

> 실시간서버log보여줌

**heroku연결**

> heroku git:remote -a "app이름"
>
> push 할때는 git push origin main && git push heroku main 
>
> 내 깃 저장소랑 heroku에 같이 푸시 
>
> => 안되네  그냥 따로따로 푸시

**mongoDB Atals**

연결방법: MongoDB's native drivers로

**DB_URL 설정**

> heroku admin panel이용
>
> : heroku앱 => Settings =>  Reveal Config Vars에
>
> key: DB_URL
>
> value: Mongo Atals에서 받은 url
>
> COOKIE_SECRET도 같은방법으로
>
> 근데 왜 process.env.DB_URL, process.env.COOKIE_SECRET 이렇게 적었는데 되는거지??
>
> 그냥 process.env가 접근방법인가보다
>
> ```javascript
> //server.js
> secret:process.env.COOKIE_SECRET
> //db.js
> mongoose.connect(process.env.DB_URL, {
> useNewUrlParser: true,
> useUnifiedTopology: true,
> });
> ```

**Heroku는 자동으로 npm run build 후 package.json에 있는 모든걸 설치하고 npm start를 한다**  

> 이거 진짜 중요 패키지설치할때 --save 안해주고 그냥했을때 package.json에 dependencies로 안들어가면 노드모듈을 못읽음

Heroku는 랜덤으로 port를 줌

```javascript
//init.js
const PORT = process.env.PORT || 4000;
```



**Github을 통해 배포**

그냥 push만 해주면 자동으로 배포



**AWS**

client

1. buket 만들기

   Storage => S3 => Create bucket 

2. API key 만들기

   그래야 node.js 코드가 AWS와 통신가능

   service => IAM => Users => Add users => check Programmatic access(로그인할때 access key 사용) => check AmazonS3FullAccess => next: Tags => Create user => Access key ID, Secret access key 가 뜨는데 단 한번만 보여줌 => env파일에 저장, heroku var에 저장

3. Multer S3 패키지 사용

   https://www.npmjs.com/package/multer-s3

   npm i --save multer-s3

   +aws 패키지 설치

   npm i aws-sdk

   Multer S3는 Multer를 사용할 수 있게 도와줌

   upload 할때 ex) video, avatar  두가지를 변경해야함

   ```javascript
   //middlewares.js
   import multer from "multer";
   import multerS3 from "multer-s3";
   import aws from "aws-sdk";
   
   const s3 = new aws.S3({
     credentials: {
       accessKeyId: process.env.AWS_ID,
       secretAccessKey: process.env.AWS_SECRET,
       //heroku에도 같은 변수명
     },
   });
   
   const multerUploader = multerS3({
     s3: s3,
     bucket: "gyeomtube", //bucket이름
   });
   
   export const avatarUpload = multer({
     dest: "uploads/avatars/",
     limits: {
       fileSize: 3000000,
     },
     storage: multerUploader,
   });
   
   export const videoUpload = multer({
     dest: "uploads/videos/",
     limits: {
       fileSize: 10000000,
     },
     storage: multerUploader,
   });
   //storage 추가
   ```



세가지문제 

1. object가 비공개인거

   => s3 => permissions

   ![image-20211214185630027](https://raw.githubusercontent.com/rladbrua0207/image_repo/main/img/image-20211214185630027.png)	

2. Access Control List 전달

   ACL은 기본적으로 object의 권한

   bucket 밑에 acl: "public-read", 써주기(안써주면 사진로드 X 안써줘서 계속 헤맴,,)

3. file을 받아올때 file.path로 받아왔었는데 이제는 AWS으로 업로드 돼 file.location으로 접근해야한다



**Production Environment**

heroku에서 작업할땐 multer uploader만 사용

> process.env.NODE_ENV (heroku에서만 읽을수있음)
>
> =>"production"

local에서 작업할땐 파일 시스템을 uploader만 사용하도록

=> multer uploader 를 2개 만들어야함

```javascript
const isHeroku = process.env.NODE_ENV === "production";

const s3 = new aws.S3({
  credentials: {
    accessKeyId: process.env.AWS_ID,
    secretAccessKey: process.env.AWS_SECRET,
    //heroku에도 같은 변수명
  },
});
const s3ImageUploader = multerS3({
  s3: s3,
  bucket: "gyeomtube/images", //bucket이름
  acl: "public-read",
});

const s3VideoUploader = multerS3({
  s3: s3,
  bucket: "gyeomtube/videos", //bucket이름
  acl: "public-read",
});
export const avatarUpload = multer({
  dest: "uploads/avatars/",
  limits: {
    fileSize: 3000000,
  },
  storage: isHeroku ? s3ImageUploader : undefined,
});

export const videoUpload = multer({
  dest: "uploads/videos/",
  limits: {
    fileSize: 10000000,
  },
  storage: isHeroku ? s3VideoUploader : undefined,
});//heroku일때만 s3사용

//dest가 multer uploader에서 작동안하므로 2개를 따로 만들어야함
```



Object업로드할때 원래있던 오브젝트가 있으면

https://velog.io/@nawnoes/Nodejs-aws-sdk-S3-%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8-%EC%82%AD%EC%A0%9C

여기 참고해서 오브젝트 삭제







전에 WebAssembly 에서

```javascript
//server 
app.use((req, res, next) => {
res.header("Cross-Origin-Embedder-Policy", "require-corp");
res.header("Cross-Origin-Opener-Policy", "same-origin");
next();
});
```

를 했었는데 이 설정때문에 비디오랑 프로필사진이 로드가 안된다 

보안적인문제?라고 FFmpeg모듈이 실행될때 다른도메인에서 오는 URL은 보안상 허용하지 않는다고 한다

그래서 다 지워버리고 그냥

```javascript
//##1
//server
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "X-Requested-With");
  res.header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
  next();
});
```

이렇게 모두가 허용되도록 바꿔줬는데

안돼서 다시
https://onlee3.github.io/clonecoding/wetubeC17/ 여기를 참고해서

```javascript
//##2
//server.js
app.use((req, res, next) => {
  res.header("Cross-Origin-Embedder-Policy", "require-corp");
  res.header("Cross-Origin-Opener-Policy", "same-origin");
  next();
});
//pug에 AWS에서 받아오는것들에 crossorigin추가
//videoControlles.js
//upload창에서 ffmpeg와 충돌이 나므로 header 추가
export const getUpload = (req, res) => {
  res.header("Cross-Origin-Embedder-Policy", "require-corp");
  res.header("Cross-Origin-Opener-Policy", "same-origin");
  return res.render("upload", { pageTitle: "Upload Video" });
};
//위에 참고사이트에서는 getupload에 header를 추가해주는데 어차피 getupload를 router에서 부르기 전에 server에서 위의 middleware를 호출해서 header를 설정할탠데 왜 getupload에서 또 설정해주는지 모르겠다 그래서 내 코드에서는 뺐다
```

이렇게 해주니깐 한번에 되는게 아니고 서서히? 됐다

근데?? 전에 했던 ##1 이 왜 안되나 싶어서 전에거 지우고 다시 ##1로 해봤는데?? 이번엔 됐다 대체 뭔지 모르겠다 대체 왜 되는거지???? 진짜 왜 안됐다가 되는지 모르겠다 안돼서 AWS에서도 CORS 설정하는게 있길래 그거도 설정 해봤다 이거는 왜하는건지 모르겠다 원래 서버에서만 CORS를 설정하는거라고 알고있는데 일단은 했다 구글링해도 왜 하는건지는 모르겠다..

또 header를 지워서 오류나게했다가 다시 header를 추가했는데 또 오류가 나온다 이게 좀 시간이 걸리는가보다



```javascript
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", "*");
  res.header("Access-Control-Allow-Headers", "X-Requested-With");
  res.header("Access-Control-Allow-Methods", "POST, GET, OPTIONS, DELETE");
  next();
});
//이거로 하면 pug에 AWS에서 파일 받아오는 태그들에 crossorigin을 빼야만 cors오류가 안난다 대신 ffmpeg 사용 당시 부딪힌 sharedArrayBuffer 에러를 해결하려고 설정한 Cross-origin 세팅을 바꾼거여서 sharedArrayBuffer오류가 난다 그래서 다시//##1로 변경했다
```

**AWS s3 CORS 설정**

참고사이트: https://velog.io/@kimsehwan96/S3-CORS-%ED%97%A4%EB%8D%94-%EA%B4%80%EB%A0%A8-%EC%9D%B4%EC%8A%88-%ED%95%B4%EA%B2%B0%EB%B0%A9%EB%B2%95-html2canvas-lottie 

```
[
    {
        "AllowedHeaders": [
            "*"
        ],
        "AllowedMethods": [
            "GET",
            "HEAD"
        ],
        "AllowedOrigins": [
            "*"
        ],
        "ExposeHeaders": [
            "x-amz-server-side-encryption",
            "x-amz-request-id",
            "x-amz-id-2"
        ],
        "MaxAgeSeconds": 3000
    }
]
```

❕❕ 알게된사실 ##1처럼 하면 AWS s3 에서 CORS 설정을 안해도 파일이 가져와지는데 ##2처럼 하면 AWS s3에서 CORS 설정을 해줘야 파일이 가져와진다 왜 이런진 모르겠다,,

그리고 위의 ##2 에서 cors오류가 서서히 해결 됐다고 했는데 그게 아니었다 이미 cors를 설정하기 전에 올렸던 파일들 때문에 어떤건 되고 어떤건 안돼서 그렇게 느낀거 같다

ffmpeg충돌만 아니라면 그냥 ##1처럼 하는게 간단하고 AWS에서도 CORS 설정을 굳이 할 필요가 없는거같다 근데 또 ##1처럼 하는거는 보안에 안좋다고하기도 해서 뭐가 더 좋은방법인지는 모르겠다 .





